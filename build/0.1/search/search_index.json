{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Multimeter \ud83d\udd17 Multimeter is a library for measuring run-time properties. It is currently under development by Kantai GmbH and licensed under MIT License . Interested in first steps using multimeter? \ud83d\udd17 Take a look at our Getting started documentation . Want to learn more about the details? \ud83d\udd17 Read through our User guide to understand how it works. You have questions? \ud83d\udd17 Maybe we already have the answers . If you can't find the answers there, reach out to us. Our support channels can be found on our documentation home on https://docs.kant.ai .","title":"Home"},{"location":"#multimeter","text":"Multimeter is a library for measuring run-time properties. It is currently under development by Kantai GmbH and licensed under MIT License .","title":"Multimeter"},{"location":"#interested-in-first-steps-using-multimeter","text":"Take a look at our Getting started documentation .","title":"Interested in first steps using multimeter?"},{"location":"#want-to-learn-more-about-the-details","text":"Read through our User guide to understand how it works.","title":"Want to learn more about the details?"},{"location":"#you-have-questions","text":"Maybe we already have the answers . If you can't find the answers there, reach out to us. Our support channels can be found on our documentation home on https://docs.kant.ai .","title":"You have questions?"},{"location":"api/","text":"Measure resource usage of your python code measure \ud83d\udd17 Contains Measure class Measure \ud83d\udd17 Class that represents a metric that is gathered on a subject. Attributes: Name Type Description key str The (unique) key that is used for referencing a measure. The key is derived from the keys of the subject and the metric in the form <subject-key>.<metric-key> . subject multimeter.subject.Subject The subject on which the measure gathers data. metric multimeter.metric.Metric The metric which is gathered. measurement \ud83d\udd17 Measuring run-time properties Measurement \ud83d\udd17 Class that is used for a single series of measurement. Attributes: Name Type Description identifier str The (unique) identifier for this series of measurement. tags Dict[str,str] A set of user-defined tags that can be used for later differentiation between different series. result multimeter.result.Result The result of the series of measurement containing the measured values. __init__ ( self , multimeter , identifier , ** tags ) special \ud83d\udd17 Creates a new measurement. Parameters: Name Type Description Default multimeter multimeter.multimeter.Multimeter The multimeter whose configuration should be used for this measurement. required identifier The (unique) identifier for this series of measurement. If None , a unique identifier is generated from the current time. required **tags Dict[str,str] A set of user-defined tags that can be used for later differentiation between different measurements. {} Source code in multimeter/measurement.py def __init__ ( self , multimeter , identifier , ** tags ): \"\"\" Creates a new measurement. Args: multimeter (multimeter.multimeter.Multimeter): The multimeter whose configuration should be used for this measurement. identifier: The (unique) identifier for this series of measurement. If `None`, a unique identifier is generated from the current time. **tags (Dict[str,str]): A set of user-defined tags that can be used for later differentiation between different measurements. \"\"\" self . identifier = identifier or str ( time . time ()) self . tags = tags self . result = None self . _probes = multimeter . probes self . _storage = multimeter . storage self . _thread = _MeasuringThread ( self . _sample , cycle_time = multimeter . cycle_time ) self . _time_last_sample = None add_mark ( self , label ) \ud83d\udd17 Add a new mark for the current time. Parameters: Name Type Description Default label str The label of the mark. required Source code in multimeter/measurement.py def add_mark ( self , label ): \"\"\" Add a new mark for the current time. Args: label (str): The label of the mark. \"\"\" timestamp = datetime . datetime . now ( datetime . timezone . utc ) self . result . add_mark ( timestamp , label ) end ( self ) \ud83d\udd17 Ends the process of gathering run-time property values. Source code in multimeter/measurement.py def end ( self ): \"\"\" Ends the process of gathering run-time property values. \"\"\" self . _thread . end () self . _thread . join () for probe in self . _probes : probe . end () self . _storage . store ( self . result ) start ( self ) \ud83d\udd17 Starts the process of gathering run-time property values. Returns: Type Description multimeter.result.Result The result of this series of measurement. Source code in multimeter/measurement.py def start ( self ): \"\"\" Starts the process of gathering run-time property values. Returns: multimeter.result.Result: The result of this series of measurement. \"\"\" self . result = Result ( * self . _probes , identifier = self . identifier , tags = self . tags ) self . _time_last_sample = time . monotonic () for probe in self . _probes : probe . start () self . _thread . start () return self . result metric \ud83d\udd17 Metrics that define the type of measured values Metric \ud83d\udd17 Class representing a metric describing the type of measured values. Attributes: Name Type Description key str The (unique) key that is used for referencing a metric. description str A human readable description of the metric. Defaults to the empty string \"\" . unit str The unit in which the value of metric is expressed. Defaults to the empty string \"\" . value_type type The python type used for the values of this metric. Defaults to float . min_value value_type The minimum value that this metric can produce. Defaults to 0.0 , but can be set to None to disable limitation. max_value value_type The maximum value that this metric can produce. Defaults to None which disables limitation. limit_value ( self , value ) \ud83d\udd17 Make sure the value is in the limits of this metric. If the given value is larger than max_value or smaller than min_value the value is capped. Parameters: Name Type Description Default value value_type The value tp limit. required Returns: Type Description value_type The limited value. Source code in multimeter/metric.py def limit_value ( self , value ): \"\"\" Make sure the value is in the limits of this metric. If the given value is larger than `max_value` or smaller than `min_value` the value is capped. Args: value (value_type): The value tp limit. Returns: value_type: The limited value. \"\"\" if self . min_value is not None : value = max ( self . min_value , value ) if self . max_value is not None : value = min ( self . max_value , value ) return value multimeter \ud83d\udd17 The module defining the Multimeter class Multimeter \ud83d\udd17 A Multimeter object allows to measure run-time properties of python code. The multi meter uses multimeter.probe.Probe objects that are used for actually measuring some metrics on individual subjects. Those probes are defined, when a new instance of Multimeter is created. A new series of measurement is created when the method measure() is being called. The measuring process itself is started by calling start() and runs until it is ended by calling end() . The measuring happens in a different thread so that it runs in the background automatically. When the measurement is ended, its multimeter.result.Result can be retrieved from the measurement itself. Examples: >>> multimeter = Multimeter ( ResourceProbe ()) >>> measurement = multimeter . measure () >>> measurement . start () >>> here_my_code_to_be_measured () ... >>> measurement . end () >>> result = measurement . result Alternatively, Measurement can be used as a context manager, that returns the result: Examples: >>> multimeter = Multimeter ( ResourceProbe ()) >>> with multimeter . measure () as result : ... here_my_code_to_be_measured () ... cycle_time property readonly \ud83d\udd17 Returns the cycle time in seconds, how often data is gathered. probes property readonly \ud83d\udd17 Returns the probes that gather the data. storage property readonly \ud83d\udd17 Returns the storage. __init__ ( self , * probes , * , cycle_time = 1.0 , storage =< multimeter . storages . dummy . DummyStorage object at 0x7f76ff562fd0 > ) special \ud83d\udd17 Create a new multi meter. Parameters: Name Type Description Default *probes multimeter.probe.Probe A list of probes that measure. () cycle_time float The time in seconds between two measure points. Defaults to 1.0 . which means measure every second. 1.0 storage multimeter.storage.Storage A instance of Storage that takes care of storing the final result. Defaults to an implementation that doesn't do anything. <multimeter.storages.dummy.DummyStorage object at 0x7f76ff562fd0> Source code in multimeter/multimeter.py def __init__ ( self , * probes , cycle_time = 1.0 , storage = DummyStorage ()): \"\"\" Create a new multi meter. Args: *probes (multimeter.probe.Probe): A list of probes that measure. cycle_time (float): The time in seconds between two measure points. Defaults to `1.0`. which means measure every second. storage (multimeter.storage.Storage): A instance of `Storage` that takes care of storing the final result. Defaults to an implementation that doesn't do anything. \"\"\" self . _cycle_time = cycle_time self . _probes = [ * probes ] self . _storage = storage add_probes ( self , * probes ) \ud83d\udd17 Add probes that gather data. Parameters: Name Type Description Default *probes multimeter.probe.Probe Objects that implement the Probe protocol. () Returns: Type Description Multimeter The multimeter. Source code in multimeter/multimeter.py def add_probes ( self , * probes ): \"\"\" Add probes that gather data. Args: *probes (multimeter.probe.Probe): Objects that implement the Probe protocol. Returns: Multimeter: The multimeter. \"\"\" self . _probes . extend ( probes ) return self measure ( self , identifier = None , ** tags ) \ud83d\udd17 Create a new measurement based on the multimeters configuration. Parameters: Name Type Description Default identifier str The (unique) identifier for this measurement. None **tags Dict[str,str] Optional user-defined tags, that can be used later for identifying the measurement. {} Returns: Type Description multimeter.measurement.Measurement The new measurement object which is used for starting and ending the process. Source code in multimeter/multimeter.py def measure ( self , identifier = None , ** tags ): \"\"\" Create a new measurement based on the multimeters configuration. Args: identifier (str): The (unique) identifier for this measurement. **tags (Dict[str,str]): Optional user-defined tags, that can be used later for identifying the measurement. Returns: multimeter.measurement.Measurement: The new measurement object which is used for starting and ending the process. \"\"\" return Measurement ( self , identifier , ** tags ) set_cycle_time ( self , cycle_time ) \ud83d\udd17 Sets the cycle time, how often data is gathered. Parameters: Name Type Description Default cycle_time float The time between two sequential data gatherings. required Returns: Type Description Multimeter The multimeter. Source code in multimeter/multimeter.py def set_cycle_time ( self , cycle_time ): \"\"\" Sets the cycle time, how often data is gathered. Args: cycle_time (float): The time between two sequential data gatherings. Returns: Multimeter: The multimeter. \"\"\" self . _cycle_time = cycle_time return self set_storage ( self , storage ) \ud83d\udd17 Sets the storage. Parameters: Name Type Description Default storage multimeter.storage.Storage The storage that stores the results. required Returns: Type Description Multimeter The multimeter. Source code in multimeter/multimeter.py def set_storage ( self , storage ): \"\"\" Sets the storage. Args: storage (multimeter.storage.Storage): The storage that stores the results. Returns: Multimeter: The multimeter. \"\"\" self . _storage = storage return self probe \ud83d\udd17 Contains the protocol for probes which gather the data Probe ( ABC ) \ud83d\udd17 Protocol that is used for gathering run-time properties. measures property readonly \ud83d\udd17 The measures that will be gathered. Returns: Type Description tuple[multimeter.measure.Measure] A tuple of measures from which data is gathered by this probe. metrics property readonly \ud83d\udd17 The metrics used by this probe. Returns: Type Description tuple[multimeter.metric.Metric] A tuple of metrics that are gathered by this probe. subjects property readonly \ud83d\udd17 The subjects from which measures will be gathered. Returns: Type Description tuple[multimeter.subject.Subject] A tuple of subjects from which data is gathered by this probe. end ( self ) \ud83d\udd17 Signals to the probe that the gathering process is ended. Source code in multimeter/probe.py def end ( self ): \"\"\" Signals to the probe that the gathering process is ended. \"\"\" sample ( self , values , time_elapsed ) \ud83d\udd17 Sample all measures of this probe and store their current values. Parameters: Name Type Description Default values Dict[str,any] The dictionary where the values should be stored. The probe is expected to add the values for every measure under their key. required time_elapsed float Time elapsed in seconds since the last sampling. required Source code in multimeter/probe.py @abc . abstractmethod def sample ( self , values , time_elapsed ): \"\"\" Sample all measures of this probe and store their current values. Args: values (Dict[str,any]): The dictionary where the values should be stored. The probe is expected to add the values for every measure under their key. time_elapsed (float): Time elapsed in seconds since the last sampling. \"\"\" start ( self ) \ud83d\udd17 Signals to the probe that it should start the gathering process. Source code in multimeter/probe.py def start ( self ): \"\"\" Signals to the probe that it should start the gathering process. \"\"\" ResourceProbe ( Probe ) \ud83d\udd17 Probe which gathers data using the python resource module. measures property readonly \ud83d\udd17 The measures that will be gathered. Returns: Type Description tuple[multimeter.measure.Measure] A tuple of measures from which data is gathered by this probe. metrics property readonly \ud83d\udd17 The metrics used by this probe. Returns: Type Description tuple[multimeter.metric.Metric] A tuple of metrics that are gathered by this probe. subjects property readonly \ud83d\udd17 The subjects from which measures will be gathered. Returns: Type Description tuple[multimeter.subject.Subject] A tuple of subjects from which data is gathered by this probe. sample ( self , values , time_elapsed ) \ud83d\udd17 Sample all measures of this probe and store their current values. Parameters: Name Type Description Default values Dict[str,any] The dictionary where the values should be stored. The probe is expected to add the values for every measure under their key. required time_elapsed float Time elapsed in seconds since the last sampling. required Source code in multimeter/probe.py def sample ( self , values , time_elapsed ): if self . _last_process_values is None or self . _last_children_values is None : raise RuntimeError ( \"Need to start before sampling.\" ) usage = resource . getrusage ( resource . RUSAGE_SELF ) self . _add_to_data ( values , 'process.' , usage , self . _last_process_values , time_elapsed ) self . _last_process_values = usage usage = resource . getrusage ( resource . RUSAGE_CHILDREN ) self . _add_to_data ( values , 'children.' , usage , self . _last_children_values , time_elapsed ) self . _last_children_values = usage start ( self ) \ud83d\udd17 Signals to the probe that it should start the gathering process. Source code in multimeter/probe.py def start ( self ): self . _last_process_values = resource . getrusage ( resource . RUSAGE_SELF ) self . _last_children_values = resource . getrusage ( resource . RUSAGE_CHILDREN ) result \ud83d\udd17 Contains classes for representing the results of a measurement Mark \ud83d\udd17 Class that contains a mark for a specified time with an annotation. Attributes: Name Type Description datetime datetime.datetime The timestamp in UTC. label str The annotation of the mark. Point \ud83d\udd17 Class that contains the values of a single measurement point. Attributes: Name Type Description datetime datetime.datetime The timestamp in UTC. values dict[string, any] The Result \ud83d\udd17 Class representing results of a measurement. Attributes: Name Type Description identifier str A string, that identifies the measurement. tags Dict[string,string] A set of user-defined tags with arbitrary string values. meta_data Dict[string,string] A dictionary with meta data about the measurement. schema multimeter.result.Schema The schema of the values that are used in this result. points tuple[multimeter.result.Point A list of measurement points, which contain the measured values with their timestamp. marks tuple[multimeter.result.Mark A tuple of marks that were set at specific times during measuring. duration property readonly \ud83d\udd17 Returns: Type Description datetime.timedelta The duration between first and last measurement or None if nothing was measured. end property readonly \ud83d\udd17 Returns: Type Description datetime.datetime The timestamp of the last measurement or None if nothing was measured. marks property readonly \ud83d\udd17 Returns a tuple containing the marks points property readonly \ud83d\udd17 Returns a tuple containing the points start property readonly \ud83d\udd17 Returns: Type Description datetime.datetime The timestamp of the first measurement or None if nothing was measured. add_mark ( self , timestamp , label ) \ud83d\udd17 Add a new mark for the given timestamp. Parameters: Name Type Description Default timestamp datetime.datetime The timestamp when the values were sampled. required label str The label of the mark. required Source code in multimeter/result.py def add_mark ( self , timestamp , label ): \"\"\" Add a new mark for the given timestamp. Args: timestamp (datetime.datetime): The timestamp when the values were sampled. label (str): The label of the mark. \"\"\" self . _marks . append ( Mark ( timestamp , label )) add_meta_data ( self , ** meta_data ) \ud83d\udd17 Adds meta data to the result. Setting a value for a key the second time, will overwrite the value set the first time. Source code in multimeter/result.py def add_meta_data ( self , ** meta_data ): \"\"\" Adds meta data to the result. Setting a value for a key the second time, will overwrite the value set the first time. Keyword Args: **meta_data: The set of meta data in form of keyword args that should be added to the result. \"\"\" self . meta_data . update ( ** meta_data ) append ( self , timestamp , values ) \ud83d\udd17 Add a new point with measured values to the result. Parameters: Name Type Description Default timestamp datetime.datetime The timestamp when the values were sampled. required values Dict[str,any] The values. required Source code in multimeter/result.py def append ( self , timestamp , values ): \"\"\" Add a new point with measured values to the result. Args: timestamp (datetime.datetime): The timestamp when the values were sampled. values (Dict[str,any]): The values. \"\"\" self . _points . append ( Point ( timestamp , values )) values ( self , key ) \ud83d\udd17 Returns all values of a specific measure. Parameters: Name Type Description Default key str Key of the measure for which all values should be returned. required Yields any: A value of the type defined by the metric. Source code in multimeter/result.py def values ( self , key ): \"\"\" Returns all values of a specific measure. Args: key (str): Key of the measure for which all values should be returned. Yields: any: A value of the type defined by the metric. \"\"\" return ( point . values [ key ] for point in self . _points ) Schema \ud83d\udd17 Class that represents the schema of the values in a result. The schema consists of the used metrics, the subjects of the measures and the measures, which define which metric is measured on which subject. Attributes: Name Type Description metrics tuple[multimeter.metric.Metric A list of metrics which are measured. subjects tuple[multimeter.subject.Subject A list of subjects on which some metrics were measured. measures tuple[multimeter.measure.Measure A list of measures, which contains which metrics were measured on which subjects. storages special \ud83d\udd17 base \ud83d\udd17 Base class Storage for measurement results Storage ( ABC ) \ud83d\udd17 Base class for implementing storages, which store the results of measurements. store ( self , result ) \ud83d\udd17 Store the result. Parameters: Name Type Description Default result multimeter.result.Result The result to be stored. required Source code in multimeter/storages/base.py @abc . abstractmethod def store ( self , result ): \"\"\" Store the result. Args: result (multimeter.result.Result): The result to be stored. \"\"\" dummy \ud83d\udd17 Storage for measurement results DummyStorage ( Storage ) \ud83d\udd17 Dummy Storage implementation store ( self , result ) \ud83d\udd17 Store the result. Parameters: Name Type Description Default result multimeter.result.Result The result to be stored. required Source code in multimeter/storages/dummy.py def store ( self , result ): pass file \ud83d\udd17 Storage that stores results in files FileFormat ( ABC ) \ud83d\udd17 Abstract base class for the different file format implementations. extension property readonly \ud83d\udd17 Returns the file extensions for the file, e.g. '.json'. save_result_to_stream ( self , result , stream ) \ud83d\udd17 Saves the result to a binary stream. Parameters: Name Type Description Default result multimeter.result.Result The result. required stream io.RawIOBase Binary stream where the result is written to. required Source code in multimeter/storages/file.py @abc . abstractmethod def save_result_to_stream ( self , result , stream ): \"\"\" Saves the result to a binary stream. Args: result (multimeter.result.Result): The result. stream (io.RawIOBase): Binary stream where the result is written to. \"\"\" FileStorage ( Storage ) \ud83d\udd17 Storage implementation that stores results as JSON files in a directory. Attributes: Name Type Description save_directory pathlib.Path The path to the directory where the results are stored. file_format multimeter.storages.file.FileFormat The file format to use. save_directory property readonly \ud83d\udd17 Returns the save directory. __init__ ( self , save_directory , file_format ) special \ud83d\udd17 Creates a new file storage. Parameters: Name Type Description Default save_directory Union[str,pathlib.Path] The path to a directory, where the json files will be stored. required file_format FileFormat The format to use for the file. required Source code in multimeter/storages/file.py def __init__ ( self , save_directory , file_format ): \"\"\" Creates a new file storage. Args: save_directory (Union[str,pathlib.Path]): The path to a directory, where the json files will be stored. file_format (FileFormat): The format to use for the file. \"\"\" if save_directory is None : raise ValueError ( \"'save_directory' must be set.\" ) if not isinstance ( save_directory , pathlib . Path ): save_directory = pathlib . Path ( save_directory ) self . _save_directory = save_directory self . _file_format = file_format store ( self , result ) \ud83d\udd17 Store the result. Parameters: Name Type Description Default result multimeter.result.Result The result to be stored. required Source code in multimeter/storages/file.py def store ( self , result ): if not self . _save_directory . exists (): self . _save_directory . mkdir ( parents = True ) result_file_path = self . _save_directory / ( result . identifier + self . _file_format . extension ) with open ( result_file_path , 'bw' ) as stream : self . _file_format . save_result_to_stream ( result , stream ) JsonFormat ( FileFormat ) \ud83d\udd17 Format implementation that stores results as JSON. extension property readonly \ud83d\udd17 Returns the file extensions for the file, e.g. '.json'. save_result_to_stream ( self , result , stream ) \ud83d\udd17 Saves the result to a (binary) stream. Parameters: Name Type Description Default result multimeter.result.Result The result to save. required stream io.RawIOBase The binary stream into which the result data should be written. The stream is not automatically closed. required Source code in multimeter/storages/file.py def save_result_to_stream ( self , result , stream ): \"\"\" Saves the result to a (binary) stream. Args: result (multimeter.result.Result): The result to save. stream (io.RawIOBase): The binary stream into which the result data should be written. The stream is not automatically closed. \"\"\" text_stream = io . TextIOWrapper ( stream , encoding = 'utf-8' ) metrics_json = _SerializableGenerator ( { 'key' : o . key , 'description' : o . description , 'unit' : o . unit , 'value_type' : o . value_type . __name__ , 'min_value' : o . min_value , 'max_value' : o . max_value , } for o in result . schema . metrics ) subjects_json = _SerializableGenerator ( { 'key' : o . key , 'description' : o . description , } for o in result . schema . subjects ) measures_json = _SerializableGenerator ( { 'key' : o . key , 'subject' : o . subject . key , 'metric' : o . metric . key , } for o in result . schema . measures ) points_json = _SerializableGenerator ( { 'datetime' : o . datetime . isoformat ( timespec = 'milliseconds' ), 'values' : o . values , } for o in result . points ) marks_json = _SerializableGenerator ( { 'datetime' : o . datetime . isoformat ( timespec = 'milliseconds' ), 'label' : o . label , } for o in result . marks ) result_json = { 'identifier' : result . identifier , 'tags' : result . tags , 'meta_data' : result . meta_data , 'schema' : { 'metrics' : metrics_json , 'subjects' : subjects_json , 'measures' : measures_json , }, 'points' : points_json , 'marks' : marks_json , } json . dump ( result_json , text_stream , indent = 2 ) text_stream . detach () LineFormat ( FileFormat ) \ud83d\udd17 Format implementation that stores results as Line format. The format is used by time series databases like InfluxDB. For more information: https://docs.influxdata.com/influxdb/v2.1/reference/syntax/line-protocol/#string extension property readonly \ud83d\udd17 Returns the file extensions for the file, e.g. '.json'. save_result_to_stream ( self , result , stream ) \ud83d\udd17 Saves the result to a (binary) stream. Parameters: Name Type Description Default result multimeter.result.Result The result to save. required stream io.RawIOBase The binary stream into which the result data should be written. The stream is not automatically closed. required Source code in multimeter/storages/file.py def save_result_to_stream ( self , result , stream ): \"\"\" Saves the result to a (binary) stream. Args: result (multimeter.result.Result): The result to save. stream (io.RawIOBase): The binary stream into which the result data should be written. The stream is not automatically closed. \"\"\" self . _check_measurement_identifier ( result . identifier ) text_stream = io . TextIOWrapper ( stream , encoding = 'utf-8' ) tags = '' . join ( f \", { self . _escape_tag ( key ) } = { self . _escape_tag ( value ) } \" for key , value in result . tags . items () ) identifier = self . _escape_identifier ( result . identifier ) for point in result . points : values = ',' . join ( f ' { self . _escape_field_key ( key ) } = { self . _value_as_string ( value ) } ' for key , value in point . values . items () ) # convert from seconds to nano timestamp = int ( point . datetime . timestamp () * 1000 * 1000 * 1000 ) text_stream . write ( f ' { identifier }{ tags } { values } { timestamp } \\n ' ) text_stream . detach () influx \ud83d\udd17 Store measurements in an InfluxDB InfluxDBStorage ( Storage ) \ud83d\udd17 Storage implementation that stores results in InfluxDB. The identifier of the result is used as the \"measurement\". The results from the measured are mapped to InfluxDB fields and tags are supported as well. The constructor of the storage allows to configure, under which org and in which bucket the data will be stored. Which InfluxDB to use is configured by the url argument, authorization is done using an authorization token, that has to be generated from the InfluxDB server. __init__ ( self , token , url = 'http://localhost:8086' , org = 'kantai' , bucket = 'multimeter' ) special \ud83d\udd17 Creates a new InfluxDB storage. Parameters: Name Type Description Default token str The authentication token for InfluxDB. required url url The URL to the InfluxDB instance. Defaults to 'http://localhost:8086'. 'http://localhost:8086' org str The id of the organization which should own the data. Defaults to 'kantai'. 'kantai' bucket str The bucket where the data will be stored. Defaults to 'multimeter'. 'multimeter' Source code in multimeter/storages/influx.py def __init__ ( self , token , url = \"http://localhost:8086\" , org = \"kantai\" , bucket = \"multimeter\" , ): \"\"\" Creates a new InfluxDB storage. Args: token (str): The authentication token for InfluxDB. url (url): The URL to the InfluxDB instance. Defaults to 'http://localhost:8086'. org (str): The id of the organization which should own the data. Defaults to 'kantai'. bucket (str): The bucket where the data will be stored. Defaults to 'multimeter'. \"\"\" if token is None : raise ValueError ( \"'token' must be set.\" ) self . _bucket = bucket self . _client = influxdb_client . InfluxDBClient ( url , token , org = org ) logger . info ( \"Created influxdb client with url ' %s ', org ' %s '.\" , url , org ) store ( self , result ) \ud83d\udd17 Store the result. Parameters: Name Type Description Default result multimeter.result.Result The result to be stored. required Source code in multimeter/storages/influx.py def store ( self , result ): def create_influxdb_point ( identifier , point ): influx_point = influxdb_client . Point ( identifier ) . time ( point . datetime ) for field , value in point . values . items (): influx_point . field ( field , value ) return influx_point point_settings = influxdb_client . client . write_api . PointSettings () for label , value in result . tags . items (): point_settings . add_default_tag ( label , value ) write_client = self . _client . write_api ( write_options = influxdb_client . client . write_api . SYNCHRONOUS , point_settings = point_settings , ) records = ( create_influxdb_point ( result . identifier , point ) for point in result . points ) logger . info ( \"Write new measurement %s to data base\" , result . identifier ) write_client . write ( bucket = self . _bucket , record = records ) subject \ud83d\udd17 Types for representing subjects Subject \ud83d\udd17 Class representing a measurement subject. Attributes: Name Type Description key str The key how the subject is referenced in measures. description str Description of the subject. visualization \ud83d\udd17 Command line tool for setting up a docker based visualization install ( args ) \ud83d\udd17 Install the visualization container and configure them. Parameters: Name Type Description Default args argparse.Namespace The arguments parsed from command-line. required Source code in multimeter/visualization.py def install ( args ): # pylint: disable=too-many-locals \"\"\" Install the visualization container and configure them. Args: args (argparse.Namespace): The arguments parsed from command-line. \"\"\" config_file_path = pathlib . Path ( args . config_file ) if config_file_path . exists (): logger . error ( \"Visualization config already found at %s \" , args . config_file ) sys . exit ( - 2 ) data_directory = pathlib . Path ( args . data_dir ) multimeter_directory = pathlib . Path ( __file__ ) . parent visu_resources_directory = multimeter_directory / 'visualization' grafana_resources_directory = visu_resources_directory / 'grafana' grafana_provisioning_directory = grafana_resources_directory / 'provisioning' grafana_dashboards_templates_directory = grafana_resources_directory / 'dashboards' influx_resources_directory = visu_resources_directory / 'influxdb' org = args . org data_bucket = args . bucket data_directory . mkdir ( parents = True , exist_ok = True ) influx_dir = data_directory / 'influxdb' influx_dir . mkdir ( exist_ok = True ) influx_data_dir = influx_dir / 'data' influx_data_dir . mkdir ( exist_ok = True ) influx_config_dir = influx_dir / 'config' influx_config_dir . mkdir ( exist_ok = True ) grafana_dir = data_directory / 'grafana' new_env = { 'UID' : str ( os . getuid ()), 'DATA_DIR' : str ( data_directory . absolute ()), 'INFLUX_ADMIN' : 'admin' , 'INFLUX_PASSWORD' : 'admin123' , 'INFLUX_ORG' : org , 'INFLUX_BUCKET' : data_bucket , 'GRAFANA_PROVISIONING_DIR' : str ( grafana_provisioning_directory . absolute ()), } # Starting only influxdb logger . info ( \"Create and start influxdb...\" ) _execute_docker_command ( 'up' , '-d' , 'influxdb2' , env = new_env ) logger . info ( \"Waiting for influxdb to come up...\" ) time . sleep ( 5 ) # create authorization token logger . info ( \"Create influxdb authorization token for grafana\" ) output = _execute_docker_command ( 'exec' , 'influxdb2' , 'influx' , 'auth' , 'create' , '-o' , org , '-d' , '\"Token for Grafana access\"' , '--all-access' , '--json' , env = new_env , ) json_result = json . loads ( output ) token = json_result [ 'token' ] logger . debug ( \"Created token %s \" , token ) new_env [ 'GRAFANA_INFLUX_DATA_SOURCE_TOKEN' ] = token # load example data logger . info ( \"Load example data into influxdb\" ) _load_example_data ( influx_data_dir , influx_resources_directory ) _execute_docker_command ( 'exec' , 'influxdb2' , 'influx' , 'write' , '-o' , org , '-b' , data_bucket , '-t' , token , '-f' , '/var/lib/influxdb2/example.line' , env = new_env , ) _copy_dashboards_from_templates ( data_bucket , grafana_dashboards_templates_directory , grafana_dir ) logger . info ( \"Create and start grafana...\" ) _execute_docker_command ( 'up' , '-d' , 'grafana8' , env = new_env ) _save_visu_config ( config_file_path , new_env ) _print_instructions () main ( args = None ) \ud83d\udd17 Main function for the visualization tool. Source code in multimeter/visualization.py def main ( args = None ): \"\"\" Main function for the visualization tool. \"\"\" multimeter_dir = pathlib . Path . home () / '.multimeter' multimeter_dir . mkdir ( exist_ok = True ) stdout_handler = logging . StreamHandler ( sys . stdout ) stdout_handler . setFormatter ( logging . Formatter ( fmt = ' %(message)s ' )) stdout_handler . level = logging . INFO file_handler = logging . FileHandler ( multimeter_dir / 'visu.log' ) file_handler . level = logging . DEBUG file_handler . setFormatter ( logging . Formatter ( fmt = ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' ) ) logging . basicConfig ( level = logging . DEBUG , handlers = [ stdout_handler , file_handler ], ) logger . debug ( \"Command line arguments: %s \" , args ) parser = argparse . ArgumentParser ( formatter_class = argparse . ArgumentDefaultsHelpFormatter ) parser . set_defaults ( command = lambda _ : parser . print_help ()) parser . add_argument ( '-c' , '--config' , dest = 'config_file' , help = \"The file where the config for the visualization is stored.\" , default = multimeter_dir / 'visu.config.json' , ) subparsers = parser . add_subparsers ( help = 'sub-command help' ) install_parser = subparsers . add_parser ( 'install' , help = \"Create the necessary docker container and configure them\" ) install_parser . add_argument ( '-d' , '--dir' , dest = 'data_dir' , help = \"The directory where the data will be stored.\" , default = multimeter_dir / 'sdocker-data' , ) install_parser . add_argument ( '-o' , '--org' , dest = 'org' , help = \"The organization in influx.\" , default = 'kantai' ) install_parser . add_argument ( '-b' , '--bucket' , dest = 'bucket' , help = \"The bucket in influx for storing measurements.\" , default = 'multimeter' , ) install_parser . set_defaults ( command = install ) remove_parser = subparsers . add_parser ( 'remove' , help = \"Remove docker containers and remove the stored data\" ) remove_parser . set_defaults ( command = remove ) start_parser = subparsers . add_parser ( 'start' , help = \"Start the visualization\" ) start_parser . set_defaults ( command = start ) stop_parser = subparsers . add_parser ( 'stop' , help = \"Stop the visualization\" ) stop_parser . set_defaults ( command = stop ) _check_docker_compose_available () args = parser . parse_args ( args ) args . command ( args ) remove ( args ) \ud83d\udd17 Remove the visualization container and delete the data stored for the visu. Parameters: Name Type Description Default args argparse.Namespace The arguments parsed from command-line. required Source code in multimeter/visualization.py def remove ( args ): \"\"\" Remove the visualization container and delete the data stored for the visu. Args: args (argparse.Namespace): The arguments parsed from command-line. \"\"\" config_file_path = pathlib . Path ( args . config_file ) if not config_file_path . exists (): logger . error ( \"No config file found at %s \" , args . config_file ) sys . exit ( - 3 ) with open ( config_file_path , 'r' , encoding = 'utf-8' ) as stream : environment = json . load ( stream )[ 'environment' ] logger . info ( \"Remove docker containers...\" ) _execute_docker_command ( 'down' , env = environment ) logger . info ( \"Remove data directory %s \" , str ( environment [ 'DATA_DIR' ])) shutil . rmtree ( environment [ 'DATA_DIR' ]) logger . info ( \"Remove visualization config in %s \" , str ( config_file_path )) config_file_path . unlink () start ( args ) \ud83d\udd17 Start the visualization container. Parameters: Name Type Description Default args argparse.Namespace The arguments parsed from command-line. required Source code in multimeter/visualization.py def start ( args ): \"\"\" Start the visualization container. Args: args (argparse.Namespace): The arguments parsed from command-line. \"\"\" config_file_path = pathlib . Path ( args . config_file ) if not config_file_path . exists (): logger . error ( \"No config file found at %s \" , args . config_file ) sys . exit ( - 3 ) with open ( config_file_path , 'r' , encoding = 'utf-8' ) as stream : environment = json . load ( stream )[ 'environment' ] logger . info ( \"Starting docker containers...\" ) _execute_docker_command ( 'start' , env = environment ) stop ( args ) \ud83d\udd17 Stop the visualization container. Parameters: Name Type Description Default args argparse.Namespace The arguments parsed from command-line. required Source code in multimeter/visualization.py def stop ( args ): \"\"\" Stop the visualization container. Args: args (argparse.Namespace): The arguments parsed from command-line. \"\"\" config_file_path = pathlib . Path ( args . config_file ) if not config_file_path . exists (): logger . error ( \"No config file found at %s \" , args . config_file ) sys . exit ( - 3 ) with open ( config_file_path , 'r' , encoding = 'utf-8' ) as stream : environment = json . load ( stream )[ 'environment' ] logger . info ( \"Stopping docker containers...\" ) _execute_docker_command ( 'stop' , env = environment )","title":"API"},{"location":"api/#multimeter.measure","text":"Contains Measure class","title":"measure"},{"location":"api/#multimeter.measure.Measure","text":"Class that represents a metric that is gathered on a subject. Attributes: Name Type Description key str The (unique) key that is used for referencing a measure. The key is derived from the keys of the subject and the metric in the form <subject-key>.<metric-key> . subject multimeter.subject.Subject The subject on which the measure gathers data. metric multimeter.metric.Metric The metric which is gathered.","title":"Measure"},{"location":"api/#multimeter.measurement","text":"Measuring run-time properties","title":"measurement"},{"location":"api/#multimeter.measurement.Measurement","text":"Class that is used for a single series of measurement. Attributes: Name Type Description identifier str The (unique) identifier for this series of measurement. tags Dict[str,str] A set of user-defined tags that can be used for later differentiation between different series. result multimeter.result.Result The result of the series of measurement containing the measured values.","title":"Measurement"},{"location":"api/#multimeter.measurement.Measurement.__init__","text":"Creates a new measurement. Parameters: Name Type Description Default multimeter multimeter.multimeter.Multimeter The multimeter whose configuration should be used for this measurement. required identifier The (unique) identifier for this series of measurement. If None , a unique identifier is generated from the current time. required **tags Dict[str,str] A set of user-defined tags that can be used for later differentiation between different measurements. {} Source code in multimeter/measurement.py def __init__ ( self , multimeter , identifier , ** tags ): \"\"\" Creates a new measurement. Args: multimeter (multimeter.multimeter.Multimeter): The multimeter whose configuration should be used for this measurement. identifier: The (unique) identifier for this series of measurement. If `None`, a unique identifier is generated from the current time. **tags (Dict[str,str]): A set of user-defined tags that can be used for later differentiation between different measurements. \"\"\" self . identifier = identifier or str ( time . time ()) self . tags = tags self . result = None self . _probes = multimeter . probes self . _storage = multimeter . storage self . _thread = _MeasuringThread ( self . _sample , cycle_time = multimeter . cycle_time ) self . _time_last_sample = None","title":"__init__()"},{"location":"api/#multimeter.measurement.Measurement.add_mark","text":"Add a new mark for the current time. Parameters: Name Type Description Default label str The label of the mark. required Source code in multimeter/measurement.py def add_mark ( self , label ): \"\"\" Add a new mark for the current time. Args: label (str): The label of the mark. \"\"\" timestamp = datetime . datetime . now ( datetime . timezone . utc ) self . result . add_mark ( timestamp , label )","title":"add_mark()"},{"location":"api/#multimeter.measurement.Measurement.end","text":"Ends the process of gathering run-time property values. Source code in multimeter/measurement.py def end ( self ): \"\"\" Ends the process of gathering run-time property values. \"\"\" self . _thread . end () self . _thread . join () for probe in self . _probes : probe . end () self . _storage . store ( self . result )","title":"end()"},{"location":"api/#multimeter.measurement.Measurement.start","text":"Starts the process of gathering run-time property values. Returns: Type Description multimeter.result.Result The result of this series of measurement. Source code in multimeter/measurement.py def start ( self ): \"\"\" Starts the process of gathering run-time property values. Returns: multimeter.result.Result: The result of this series of measurement. \"\"\" self . result = Result ( * self . _probes , identifier = self . identifier , tags = self . tags ) self . _time_last_sample = time . monotonic () for probe in self . _probes : probe . start () self . _thread . start () return self . result","title":"start()"},{"location":"api/#multimeter.metric","text":"Metrics that define the type of measured values","title":"metric"},{"location":"api/#multimeter.metric.Metric","text":"Class representing a metric describing the type of measured values. Attributes: Name Type Description key str The (unique) key that is used for referencing a metric. description str A human readable description of the metric. Defaults to the empty string \"\" . unit str The unit in which the value of metric is expressed. Defaults to the empty string \"\" . value_type type The python type used for the values of this metric. Defaults to float . min_value value_type The minimum value that this metric can produce. Defaults to 0.0 , but can be set to None to disable limitation. max_value value_type The maximum value that this metric can produce. Defaults to None which disables limitation.","title":"Metric"},{"location":"api/#multimeter.metric.Metric.limit_value","text":"Make sure the value is in the limits of this metric. If the given value is larger than max_value or smaller than min_value the value is capped. Parameters: Name Type Description Default value value_type The value tp limit. required Returns: Type Description value_type The limited value. Source code in multimeter/metric.py def limit_value ( self , value ): \"\"\" Make sure the value is in the limits of this metric. If the given value is larger than `max_value` or smaller than `min_value` the value is capped. Args: value (value_type): The value tp limit. Returns: value_type: The limited value. \"\"\" if self . min_value is not None : value = max ( self . min_value , value ) if self . max_value is not None : value = min ( self . max_value , value ) return value","title":"limit_value()"},{"location":"api/#multimeter.multimeter","text":"The module defining the Multimeter class","title":"multimeter"},{"location":"api/#multimeter.multimeter.Multimeter","text":"A Multimeter object allows to measure run-time properties of python code. The multi meter uses multimeter.probe.Probe objects that are used for actually measuring some metrics on individual subjects. Those probes are defined, when a new instance of Multimeter is created. A new series of measurement is created when the method measure() is being called. The measuring process itself is started by calling start() and runs until it is ended by calling end() . The measuring happens in a different thread so that it runs in the background automatically. When the measurement is ended, its multimeter.result.Result can be retrieved from the measurement itself. Examples: >>> multimeter = Multimeter ( ResourceProbe ()) >>> measurement = multimeter . measure () >>> measurement . start () >>> here_my_code_to_be_measured () ... >>> measurement . end () >>> result = measurement . result Alternatively, Measurement can be used as a context manager, that returns the result: Examples: >>> multimeter = Multimeter ( ResourceProbe ()) >>> with multimeter . measure () as result : ... here_my_code_to_be_measured () ...","title":"Multimeter"},{"location":"api/#multimeter.multimeter.Multimeter.cycle_time","text":"Returns the cycle time in seconds, how often data is gathered.","title":"cycle_time"},{"location":"api/#multimeter.multimeter.Multimeter.probes","text":"Returns the probes that gather the data.","title":"probes"},{"location":"api/#multimeter.multimeter.Multimeter.storage","text":"Returns the storage.","title":"storage"},{"location":"api/#multimeter.multimeter.Multimeter.__init__","text":"Create a new multi meter. Parameters: Name Type Description Default *probes multimeter.probe.Probe A list of probes that measure. () cycle_time float The time in seconds between two measure points. Defaults to 1.0 . which means measure every second. 1.0 storage multimeter.storage.Storage A instance of Storage that takes care of storing the final result. Defaults to an implementation that doesn't do anything. <multimeter.storages.dummy.DummyStorage object at 0x7f76ff562fd0> Source code in multimeter/multimeter.py def __init__ ( self , * probes , cycle_time = 1.0 , storage = DummyStorage ()): \"\"\" Create a new multi meter. Args: *probes (multimeter.probe.Probe): A list of probes that measure. cycle_time (float): The time in seconds between two measure points. Defaults to `1.0`. which means measure every second. storage (multimeter.storage.Storage): A instance of `Storage` that takes care of storing the final result. Defaults to an implementation that doesn't do anything. \"\"\" self . _cycle_time = cycle_time self . _probes = [ * probes ] self . _storage = storage","title":"__init__()"},{"location":"api/#multimeter.multimeter.Multimeter.add_probes","text":"Add probes that gather data. Parameters: Name Type Description Default *probes multimeter.probe.Probe Objects that implement the Probe protocol. () Returns: Type Description Multimeter The multimeter. Source code in multimeter/multimeter.py def add_probes ( self , * probes ): \"\"\" Add probes that gather data. Args: *probes (multimeter.probe.Probe): Objects that implement the Probe protocol. Returns: Multimeter: The multimeter. \"\"\" self . _probes . extend ( probes ) return self","title":"add_probes()"},{"location":"api/#multimeter.multimeter.Multimeter.measure","text":"Create a new measurement based on the multimeters configuration. Parameters: Name Type Description Default identifier str The (unique) identifier for this measurement. None **tags Dict[str,str] Optional user-defined tags, that can be used later for identifying the measurement. {} Returns: Type Description multimeter.measurement.Measurement The new measurement object which is used for starting and ending the process. Source code in multimeter/multimeter.py def measure ( self , identifier = None , ** tags ): \"\"\" Create a new measurement based on the multimeters configuration. Args: identifier (str): The (unique) identifier for this measurement. **tags (Dict[str,str]): Optional user-defined tags, that can be used later for identifying the measurement. Returns: multimeter.measurement.Measurement: The new measurement object which is used for starting and ending the process. \"\"\" return Measurement ( self , identifier , ** tags )","title":"measure()"},{"location":"api/#multimeter.multimeter.Multimeter.set_cycle_time","text":"Sets the cycle time, how often data is gathered. Parameters: Name Type Description Default cycle_time float The time between two sequential data gatherings. required Returns: Type Description Multimeter The multimeter. Source code in multimeter/multimeter.py def set_cycle_time ( self , cycle_time ): \"\"\" Sets the cycle time, how often data is gathered. Args: cycle_time (float): The time between two sequential data gatherings. Returns: Multimeter: The multimeter. \"\"\" self . _cycle_time = cycle_time return self","title":"set_cycle_time()"},{"location":"api/#multimeter.multimeter.Multimeter.set_storage","text":"Sets the storage. Parameters: Name Type Description Default storage multimeter.storage.Storage The storage that stores the results. required Returns: Type Description Multimeter The multimeter. Source code in multimeter/multimeter.py def set_storage ( self , storage ): \"\"\" Sets the storage. Args: storage (multimeter.storage.Storage): The storage that stores the results. Returns: Multimeter: The multimeter. \"\"\" self . _storage = storage return self","title":"set_storage()"},{"location":"api/#multimeter.probe","text":"Contains the protocol for probes which gather the data","title":"probe"},{"location":"api/#multimeter.probe.Probe","text":"Protocol that is used for gathering run-time properties.","title":"Probe"},{"location":"api/#multimeter.probe.Probe.measures","text":"The measures that will be gathered. Returns: Type Description tuple[multimeter.measure.Measure] A tuple of measures from which data is gathered by this probe.","title":"measures"},{"location":"api/#multimeter.probe.Probe.metrics","text":"The metrics used by this probe. Returns: Type Description tuple[multimeter.metric.Metric] A tuple of metrics that are gathered by this probe.","title":"metrics"},{"location":"api/#multimeter.probe.Probe.subjects","text":"The subjects from which measures will be gathered. Returns: Type Description tuple[multimeter.subject.Subject] A tuple of subjects from which data is gathered by this probe.","title":"subjects"},{"location":"api/#multimeter.probe.Probe.end","text":"Signals to the probe that the gathering process is ended. Source code in multimeter/probe.py def end ( self ): \"\"\" Signals to the probe that the gathering process is ended. \"\"\"","title":"end()"},{"location":"api/#multimeter.probe.Probe.sample","text":"Sample all measures of this probe and store their current values. Parameters: Name Type Description Default values Dict[str,any] The dictionary where the values should be stored. The probe is expected to add the values for every measure under their key. required time_elapsed float Time elapsed in seconds since the last sampling. required Source code in multimeter/probe.py @abc . abstractmethod def sample ( self , values , time_elapsed ): \"\"\" Sample all measures of this probe and store their current values. Args: values (Dict[str,any]): The dictionary where the values should be stored. The probe is expected to add the values for every measure under their key. time_elapsed (float): Time elapsed in seconds since the last sampling. \"\"\"","title":"sample()"},{"location":"api/#multimeter.probe.Probe.start","text":"Signals to the probe that it should start the gathering process. Source code in multimeter/probe.py def start ( self ): \"\"\" Signals to the probe that it should start the gathering process. \"\"\"","title":"start()"},{"location":"api/#multimeter.probe.ResourceProbe","text":"Probe which gathers data using the python resource module.","title":"ResourceProbe"},{"location":"api/#multimeter.probe.ResourceProbe.measures","text":"The measures that will be gathered. Returns: Type Description tuple[multimeter.measure.Measure] A tuple of measures from which data is gathered by this probe.","title":"measures"},{"location":"api/#multimeter.probe.ResourceProbe.metrics","text":"The metrics used by this probe. Returns: Type Description tuple[multimeter.metric.Metric] A tuple of metrics that are gathered by this probe.","title":"metrics"},{"location":"api/#multimeter.probe.ResourceProbe.subjects","text":"The subjects from which measures will be gathered. Returns: Type Description tuple[multimeter.subject.Subject] A tuple of subjects from which data is gathered by this probe.","title":"subjects"},{"location":"api/#multimeter.probe.ResourceProbe.sample","text":"Sample all measures of this probe and store their current values. Parameters: Name Type Description Default values Dict[str,any] The dictionary where the values should be stored. The probe is expected to add the values for every measure under their key. required time_elapsed float Time elapsed in seconds since the last sampling. required Source code in multimeter/probe.py def sample ( self , values , time_elapsed ): if self . _last_process_values is None or self . _last_children_values is None : raise RuntimeError ( \"Need to start before sampling.\" ) usage = resource . getrusage ( resource . RUSAGE_SELF ) self . _add_to_data ( values , 'process.' , usage , self . _last_process_values , time_elapsed ) self . _last_process_values = usage usage = resource . getrusage ( resource . RUSAGE_CHILDREN ) self . _add_to_data ( values , 'children.' , usage , self . _last_children_values , time_elapsed ) self . _last_children_values = usage","title":"sample()"},{"location":"api/#multimeter.probe.ResourceProbe.start","text":"Signals to the probe that it should start the gathering process. Source code in multimeter/probe.py def start ( self ): self . _last_process_values = resource . getrusage ( resource . RUSAGE_SELF ) self . _last_children_values = resource . getrusage ( resource . RUSAGE_CHILDREN )","title":"start()"},{"location":"api/#multimeter.result","text":"Contains classes for representing the results of a measurement","title":"result"},{"location":"api/#multimeter.result.Mark","text":"Class that contains a mark for a specified time with an annotation. Attributes: Name Type Description datetime datetime.datetime The timestamp in UTC. label str The annotation of the mark.","title":"Mark"},{"location":"api/#multimeter.result.Point","text":"Class that contains the values of a single measurement point. Attributes: Name Type Description datetime datetime.datetime The timestamp in UTC. values dict[string, any] The","title":"Point"},{"location":"api/#multimeter.result.Result","text":"Class representing results of a measurement. Attributes: Name Type Description identifier str A string, that identifies the measurement. tags Dict[string,string] A set of user-defined tags with arbitrary string values. meta_data Dict[string,string] A dictionary with meta data about the measurement. schema multimeter.result.Schema The schema of the values that are used in this result. points tuple[multimeter.result.Point A list of measurement points, which contain the measured values with their timestamp. marks tuple[multimeter.result.Mark A tuple of marks that were set at specific times during measuring.","title":"Result"},{"location":"api/#multimeter.result.Result.duration","text":"Returns: Type Description datetime.timedelta The duration between first and last measurement or None if nothing was measured.","title":"duration"},{"location":"api/#multimeter.result.Result.end","text":"Returns: Type Description datetime.datetime The timestamp of the last measurement or None if nothing was measured.","title":"end"},{"location":"api/#multimeter.result.Result.marks","text":"Returns a tuple containing the marks","title":"marks"},{"location":"api/#multimeter.result.Result.points","text":"Returns a tuple containing the points","title":"points"},{"location":"api/#multimeter.result.Result.start","text":"Returns: Type Description datetime.datetime The timestamp of the first measurement or None if nothing was measured.","title":"start"},{"location":"api/#multimeter.result.Result.add_mark","text":"Add a new mark for the given timestamp. Parameters: Name Type Description Default timestamp datetime.datetime The timestamp when the values were sampled. required label str The label of the mark. required Source code in multimeter/result.py def add_mark ( self , timestamp , label ): \"\"\" Add a new mark for the given timestamp. Args: timestamp (datetime.datetime): The timestamp when the values were sampled. label (str): The label of the mark. \"\"\" self . _marks . append ( Mark ( timestamp , label ))","title":"add_mark()"},{"location":"api/#multimeter.result.Result.add_meta_data","text":"Adds meta data to the result. Setting a value for a key the second time, will overwrite the value set the first time. Source code in multimeter/result.py def add_meta_data ( self , ** meta_data ): \"\"\" Adds meta data to the result. Setting a value for a key the second time, will overwrite the value set the first time. Keyword Args: **meta_data: The set of meta data in form of keyword args that should be added to the result. \"\"\" self . meta_data . update ( ** meta_data )","title":"add_meta_data()"},{"location":"api/#multimeter.result.Result.append","text":"Add a new point with measured values to the result. Parameters: Name Type Description Default timestamp datetime.datetime The timestamp when the values were sampled. required values Dict[str,any] The values. required Source code in multimeter/result.py def append ( self , timestamp , values ): \"\"\" Add a new point with measured values to the result. Args: timestamp (datetime.datetime): The timestamp when the values were sampled. values (Dict[str,any]): The values. \"\"\" self . _points . append ( Point ( timestamp , values ))","title":"append()"},{"location":"api/#multimeter.result.Result.values","text":"Returns all values of a specific measure. Parameters: Name Type Description Default key str Key of the measure for which all values should be returned. required Yields any: A value of the type defined by the metric. Source code in multimeter/result.py def values ( self , key ): \"\"\" Returns all values of a specific measure. Args: key (str): Key of the measure for which all values should be returned. Yields: any: A value of the type defined by the metric. \"\"\" return ( point . values [ key ] for point in self . _points )","title":"values()"},{"location":"api/#multimeter.result.Schema","text":"Class that represents the schema of the values in a result. The schema consists of the used metrics, the subjects of the measures and the measures, which define which metric is measured on which subject. Attributes: Name Type Description metrics tuple[multimeter.metric.Metric A list of metrics which are measured. subjects tuple[multimeter.subject.Subject A list of subjects on which some metrics were measured. measures tuple[multimeter.measure.Measure A list of measures, which contains which metrics were measured on which subjects.","title":"Schema"},{"location":"api/#multimeter.storages","text":"","title":"storages"},{"location":"api/#multimeter.storages.base","text":"Base class Storage for measurement results","title":"base"},{"location":"api/#multimeter.storages.base.Storage","text":"Base class for implementing storages, which store the results of measurements.","title":"Storage"},{"location":"api/#multimeter.storages.base.Storage.store","text":"Store the result. Parameters: Name Type Description Default result multimeter.result.Result The result to be stored. required Source code in multimeter/storages/base.py @abc . abstractmethod def store ( self , result ): \"\"\" Store the result. Args: result (multimeter.result.Result): The result to be stored. \"\"\"","title":"store()"},{"location":"api/#multimeter.storages.dummy","text":"Storage for measurement results","title":"dummy"},{"location":"api/#multimeter.storages.dummy.DummyStorage","text":"Dummy Storage implementation","title":"DummyStorage"},{"location":"api/#multimeter.storages.dummy.DummyStorage.store","text":"Store the result. Parameters: Name Type Description Default result multimeter.result.Result The result to be stored. required Source code in multimeter/storages/dummy.py def store ( self , result ): pass","title":"store()"},{"location":"api/#multimeter.storages.file","text":"Storage that stores results in files","title":"file"},{"location":"api/#multimeter.storages.file.FileFormat","text":"Abstract base class for the different file format implementations.","title":"FileFormat"},{"location":"api/#multimeter.storages.file.FileFormat.extension","text":"Returns the file extensions for the file, e.g. '.json'.","title":"extension"},{"location":"api/#multimeter.storages.file.FileFormat.save_result_to_stream","text":"Saves the result to a binary stream. Parameters: Name Type Description Default result multimeter.result.Result The result. required stream io.RawIOBase Binary stream where the result is written to. required Source code in multimeter/storages/file.py @abc . abstractmethod def save_result_to_stream ( self , result , stream ): \"\"\" Saves the result to a binary stream. Args: result (multimeter.result.Result): The result. stream (io.RawIOBase): Binary stream where the result is written to. \"\"\"","title":"save_result_to_stream()"},{"location":"api/#multimeter.storages.file.FileStorage","text":"Storage implementation that stores results as JSON files in a directory. Attributes: Name Type Description save_directory pathlib.Path The path to the directory where the results are stored. file_format multimeter.storages.file.FileFormat The file format to use.","title":"FileStorage"},{"location":"api/#multimeter.storages.file.FileStorage.save_directory","text":"Returns the save directory.","title":"save_directory"},{"location":"api/#multimeter.storages.file.FileStorage.__init__","text":"Creates a new file storage. Parameters: Name Type Description Default save_directory Union[str,pathlib.Path] The path to a directory, where the json files will be stored. required file_format FileFormat The format to use for the file. required Source code in multimeter/storages/file.py def __init__ ( self , save_directory , file_format ): \"\"\" Creates a new file storage. Args: save_directory (Union[str,pathlib.Path]): The path to a directory, where the json files will be stored. file_format (FileFormat): The format to use for the file. \"\"\" if save_directory is None : raise ValueError ( \"'save_directory' must be set.\" ) if not isinstance ( save_directory , pathlib . Path ): save_directory = pathlib . Path ( save_directory ) self . _save_directory = save_directory self . _file_format = file_format","title":"__init__()"},{"location":"api/#multimeter.storages.file.FileStorage.store","text":"Store the result. Parameters: Name Type Description Default result multimeter.result.Result The result to be stored. required Source code in multimeter/storages/file.py def store ( self , result ): if not self . _save_directory . exists (): self . _save_directory . mkdir ( parents = True ) result_file_path = self . _save_directory / ( result . identifier + self . _file_format . extension ) with open ( result_file_path , 'bw' ) as stream : self . _file_format . save_result_to_stream ( result , stream )","title":"store()"},{"location":"api/#multimeter.storages.file.JsonFormat","text":"Format implementation that stores results as JSON.","title":"JsonFormat"},{"location":"api/#multimeter.storages.file.JsonFormat.extension","text":"Returns the file extensions for the file, e.g. '.json'.","title":"extension"},{"location":"api/#multimeter.storages.file.JsonFormat.save_result_to_stream","text":"Saves the result to a (binary) stream. Parameters: Name Type Description Default result multimeter.result.Result The result to save. required stream io.RawIOBase The binary stream into which the result data should be written. The stream is not automatically closed. required Source code in multimeter/storages/file.py def save_result_to_stream ( self , result , stream ): \"\"\" Saves the result to a (binary) stream. Args: result (multimeter.result.Result): The result to save. stream (io.RawIOBase): The binary stream into which the result data should be written. The stream is not automatically closed. \"\"\" text_stream = io . TextIOWrapper ( stream , encoding = 'utf-8' ) metrics_json = _SerializableGenerator ( { 'key' : o . key , 'description' : o . description , 'unit' : o . unit , 'value_type' : o . value_type . __name__ , 'min_value' : o . min_value , 'max_value' : o . max_value , } for o in result . schema . metrics ) subjects_json = _SerializableGenerator ( { 'key' : o . key , 'description' : o . description , } for o in result . schema . subjects ) measures_json = _SerializableGenerator ( { 'key' : o . key , 'subject' : o . subject . key , 'metric' : o . metric . key , } for o in result . schema . measures ) points_json = _SerializableGenerator ( { 'datetime' : o . datetime . isoformat ( timespec = 'milliseconds' ), 'values' : o . values , } for o in result . points ) marks_json = _SerializableGenerator ( { 'datetime' : o . datetime . isoformat ( timespec = 'milliseconds' ), 'label' : o . label , } for o in result . marks ) result_json = { 'identifier' : result . identifier , 'tags' : result . tags , 'meta_data' : result . meta_data , 'schema' : { 'metrics' : metrics_json , 'subjects' : subjects_json , 'measures' : measures_json , }, 'points' : points_json , 'marks' : marks_json , } json . dump ( result_json , text_stream , indent = 2 ) text_stream . detach ()","title":"save_result_to_stream()"},{"location":"api/#multimeter.storages.file.LineFormat","text":"Format implementation that stores results as Line format. The format is used by time series databases like InfluxDB. For more information: https://docs.influxdata.com/influxdb/v2.1/reference/syntax/line-protocol/#string","title":"LineFormat"},{"location":"api/#multimeter.storages.file.LineFormat.extension","text":"Returns the file extensions for the file, e.g. '.json'.","title":"extension"},{"location":"api/#multimeter.storages.file.LineFormat.save_result_to_stream","text":"Saves the result to a (binary) stream. Parameters: Name Type Description Default result multimeter.result.Result The result to save. required stream io.RawIOBase The binary stream into which the result data should be written. The stream is not automatically closed. required Source code in multimeter/storages/file.py def save_result_to_stream ( self , result , stream ): \"\"\" Saves the result to a (binary) stream. Args: result (multimeter.result.Result): The result to save. stream (io.RawIOBase): The binary stream into which the result data should be written. The stream is not automatically closed. \"\"\" self . _check_measurement_identifier ( result . identifier ) text_stream = io . TextIOWrapper ( stream , encoding = 'utf-8' ) tags = '' . join ( f \", { self . _escape_tag ( key ) } = { self . _escape_tag ( value ) } \" for key , value in result . tags . items () ) identifier = self . _escape_identifier ( result . identifier ) for point in result . points : values = ',' . join ( f ' { self . _escape_field_key ( key ) } = { self . _value_as_string ( value ) } ' for key , value in point . values . items () ) # convert from seconds to nano timestamp = int ( point . datetime . timestamp () * 1000 * 1000 * 1000 ) text_stream . write ( f ' { identifier }{ tags } { values } { timestamp } \\n ' ) text_stream . detach ()","title":"save_result_to_stream()"},{"location":"api/#multimeter.storages.influx","text":"Store measurements in an InfluxDB","title":"influx"},{"location":"api/#multimeter.storages.influx.InfluxDBStorage","text":"Storage implementation that stores results in InfluxDB. The identifier of the result is used as the \"measurement\". The results from the measured are mapped to InfluxDB fields and tags are supported as well. The constructor of the storage allows to configure, under which org and in which bucket the data will be stored. Which InfluxDB to use is configured by the url argument, authorization is done using an authorization token, that has to be generated from the InfluxDB server.","title":"InfluxDBStorage"},{"location":"api/#multimeter.storages.influx.InfluxDBStorage.__init__","text":"Creates a new InfluxDB storage. Parameters: Name Type Description Default token str The authentication token for InfluxDB. required url url The URL to the InfluxDB instance. Defaults to 'http://localhost:8086'. 'http://localhost:8086' org str The id of the organization which should own the data. Defaults to 'kantai'. 'kantai' bucket str The bucket where the data will be stored. Defaults to 'multimeter'. 'multimeter' Source code in multimeter/storages/influx.py def __init__ ( self , token , url = \"http://localhost:8086\" , org = \"kantai\" , bucket = \"multimeter\" , ): \"\"\" Creates a new InfluxDB storage. Args: token (str): The authentication token for InfluxDB. url (url): The URL to the InfluxDB instance. Defaults to 'http://localhost:8086'. org (str): The id of the organization which should own the data. Defaults to 'kantai'. bucket (str): The bucket where the data will be stored. Defaults to 'multimeter'. \"\"\" if token is None : raise ValueError ( \"'token' must be set.\" ) self . _bucket = bucket self . _client = influxdb_client . InfluxDBClient ( url , token , org = org ) logger . info ( \"Created influxdb client with url ' %s ', org ' %s '.\" , url , org )","title":"__init__()"},{"location":"api/#multimeter.storages.influx.InfluxDBStorage.store","text":"Store the result. Parameters: Name Type Description Default result multimeter.result.Result The result to be stored. required Source code in multimeter/storages/influx.py def store ( self , result ): def create_influxdb_point ( identifier , point ): influx_point = influxdb_client . Point ( identifier ) . time ( point . datetime ) for field , value in point . values . items (): influx_point . field ( field , value ) return influx_point point_settings = influxdb_client . client . write_api . PointSettings () for label , value in result . tags . items (): point_settings . add_default_tag ( label , value ) write_client = self . _client . write_api ( write_options = influxdb_client . client . write_api . SYNCHRONOUS , point_settings = point_settings , ) records = ( create_influxdb_point ( result . identifier , point ) for point in result . points ) logger . info ( \"Write new measurement %s to data base\" , result . identifier ) write_client . write ( bucket = self . _bucket , record = records )","title":"store()"},{"location":"api/#multimeter.subject","text":"Types for representing subjects","title":"subject"},{"location":"api/#multimeter.subject.Subject","text":"Class representing a measurement subject. Attributes: Name Type Description key str The key how the subject is referenced in measures. description str Description of the subject.","title":"Subject"},{"location":"api/#multimeter.visualization","text":"Command line tool for setting up a docker based visualization","title":"visualization"},{"location":"api/#multimeter.visualization.install","text":"Install the visualization container and configure them. Parameters: Name Type Description Default args argparse.Namespace The arguments parsed from command-line. required Source code in multimeter/visualization.py def install ( args ): # pylint: disable=too-many-locals \"\"\" Install the visualization container and configure them. Args: args (argparse.Namespace): The arguments parsed from command-line. \"\"\" config_file_path = pathlib . Path ( args . config_file ) if config_file_path . exists (): logger . error ( \"Visualization config already found at %s \" , args . config_file ) sys . exit ( - 2 ) data_directory = pathlib . Path ( args . data_dir ) multimeter_directory = pathlib . Path ( __file__ ) . parent visu_resources_directory = multimeter_directory / 'visualization' grafana_resources_directory = visu_resources_directory / 'grafana' grafana_provisioning_directory = grafana_resources_directory / 'provisioning' grafana_dashboards_templates_directory = grafana_resources_directory / 'dashboards' influx_resources_directory = visu_resources_directory / 'influxdb' org = args . org data_bucket = args . bucket data_directory . mkdir ( parents = True , exist_ok = True ) influx_dir = data_directory / 'influxdb' influx_dir . mkdir ( exist_ok = True ) influx_data_dir = influx_dir / 'data' influx_data_dir . mkdir ( exist_ok = True ) influx_config_dir = influx_dir / 'config' influx_config_dir . mkdir ( exist_ok = True ) grafana_dir = data_directory / 'grafana' new_env = { 'UID' : str ( os . getuid ()), 'DATA_DIR' : str ( data_directory . absolute ()), 'INFLUX_ADMIN' : 'admin' , 'INFLUX_PASSWORD' : 'admin123' , 'INFLUX_ORG' : org , 'INFLUX_BUCKET' : data_bucket , 'GRAFANA_PROVISIONING_DIR' : str ( grafana_provisioning_directory . absolute ()), } # Starting only influxdb logger . info ( \"Create and start influxdb...\" ) _execute_docker_command ( 'up' , '-d' , 'influxdb2' , env = new_env ) logger . info ( \"Waiting for influxdb to come up...\" ) time . sleep ( 5 ) # create authorization token logger . info ( \"Create influxdb authorization token for grafana\" ) output = _execute_docker_command ( 'exec' , 'influxdb2' , 'influx' , 'auth' , 'create' , '-o' , org , '-d' , '\"Token for Grafana access\"' , '--all-access' , '--json' , env = new_env , ) json_result = json . loads ( output ) token = json_result [ 'token' ] logger . debug ( \"Created token %s \" , token ) new_env [ 'GRAFANA_INFLUX_DATA_SOURCE_TOKEN' ] = token # load example data logger . info ( \"Load example data into influxdb\" ) _load_example_data ( influx_data_dir , influx_resources_directory ) _execute_docker_command ( 'exec' , 'influxdb2' , 'influx' , 'write' , '-o' , org , '-b' , data_bucket , '-t' , token , '-f' , '/var/lib/influxdb2/example.line' , env = new_env , ) _copy_dashboards_from_templates ( data_bucket , grafana_dashboards_templates_directory , grafana_dir ) logger . info ( \"Create and start grafana...\" ) _execute_docker_command ( 'up' , '-d' , 'grafana8' , env = new_env ) _save_visu_config ( config_file_path , new_env ) _print_instructions ()","title":"install()"},{"location":"api/#multimeter.visualization.main","text":"Main function for the visualization tool. Source code in multimeter/visualization.py def main ( args = None ): \"\"\" Main function for the visualization tool. \"\"\" multimeter_dir = pathlib . Path . home () / '.multimeter' multimeter_dir . mkdir ( exist_ok = True ) stdout_handler = logging . StreamHandler ( sys . stdout ) stdout_handler . setFormatter ( logging . Formatter ( fmt = ' %(message)s ' )) stdout_handler . level = logging . INFO file_handler = logging . FileHandler ( multimeter_dir / 'visu.log' ) file_handler . level = logging . DEBUG file_handler . setFormatter ( logging . Formatter ( fmt = ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' ) ) logging . basicConfig ( level = logging . DEBUG , handlers = [ stdout_handler , file_handler ], ) logger . debug ( \"Command line arguments: %s \" , args ) parser = argparse . ArgumentParser ( formatter_class = argparse . ArgumentDefaultsHelpFormatter ) parser . set_defaults ( command = lambda _ : parser . print_help ()) parser . add_argument ( '-c' , '--config' , dest = 'config_file' , help = \"The file where the config for the visualization is stored.\" , default = multimeter_dir / 'visu.config.json' , ) subparsers = parser . add_subparsers ( help = 'sub-command help' ) install_parser = subparsers . add_parser ( 'install' , help = \"Create the necessary docker container and configure them\" ) install_parser . add_argument ( '-d' , '--dir' , dest = 'data_dir' , help = \"The directory where the data will be stored.\" , default = multimeter_dir / 'sdocker-data' , ) install_parser . add_argument ( '-o' , '--org' , dest = 'org' , help = \"The organization in influx.\" , default = 'kantai' ) install_parser . add_argument ( '-b' , '--bucket' , dest = 'bucket' , help = \"The bucket in influx for storing measurements.\" , default = 'multimeter' , ) install_parser . set_defaults ( command = install ) remove_parser = subparsers . add_parser ( 'remove' , help = \"Remove docker containers and remove the stored data\" ) remove_parser . set_defaults ( command = remove ) start_parser = subparsers . add_parser ( 'start' , help = \"Start the visualization\" ) start_parser . set_defaults ( command = start ) stop_parser = subparsers . add_parser ( 'stop' , help = \"Stop the visualization\" ) stop_parser . set_defaults ( command = stop ) _check_docker_compose_available () args = parser . parse_args ( args ) args . command ( args )","title":"main()"},{"location":"api/#multimeter.visualization.remove","text":"Remove the visualization container and delete the data stored for the visu. Parameters: Name Type Description Default args argparse.Namespace The arguments parsed from command-line. required Source code in multimeter/visualization.py def remove ( args ): \"\"\" Remove the visualization container and delete the data stored for the visu. Args: args (argparse.Namespace): The arguments parsed from command-line. \"\"\" config_file_path = pathlib . Path ( args . config_file ) if not config_file_path . exists (): logger . error ( \"No config file found at %s \" , args . config_file ) sys . exit ( - 3 ) with open ( config_file_path , 'r' , encoding = 'utf-8' ) as stream : environment = json . load ( stream )[ 'environment' ] logger . info ( \"Remove docker containers...\" ) _execute_docker_command ( 'down' , env = environment ) logger . info ( \"Remove data directory %s \" , str ( environment [ 'DATA_DIR' ])) shutil . rmtree ( environment [ 'DATA_DIR' ]) logger . info ( \"Remove visualization config in %s \" , str ( config_file_path )) config_file_path . unlink ()","title":"remove()"},{"location":"api/#multimeter.visualization.start","text":"Start the visualization container. Parameters: Name Type Description Default args argparse.Namespace The arguments parsed from command-line. required Source code in multimeter/visualization.py def start ( args ): \"\"\" Start the visualization container. Args: args (argparse.Namespace): The arguments parsed from command-line. \"\"\" config_file_path = pathlib . Path ( args . config_file ) if not config_file_path . exists (): logger . error ( \"No config file found at %s \" , args . config_file ) sys . exit ( - 3 ) with open ( config_file_path , 'r' , encoding = 'utf-8' ) as stream : environment = json . load ( stream )[ 'environment' ] logger . info ( \"Starting docker containers...\" ) _execute_docker_command ( 'start' , env = environment )","title":"start()"},{"location":"api/#multimeter.visualization.stop","text":"Stop the visualization container. Parameters: Name Type Description Default args argparse.Namespace The arguments parsed from command-line. required Source code in multimeter/visualization.py def stop ( args ): \"\"\" Stop the visualization container. Args: args (argparse.Namespace): The arguments parsed from command-line. \"\"\" config_file_path = pathlib . Path ( args . config_file ) if not config_file_path . exists (): logger . error ( \"No config file found at %s \" , args . config_file ) sys . exit ( - 3 ) with open ( config_file_path , 'r' , encoding = 'utf-8' ) as stream : environment = json . load ( stream )[ 'environment' ] logger . info ( \"Stopping docker containers...\" ) _execute_docker_command ( 'stop' , env = environment )","title":"stop()"},{"location":"changelog/","text":"Changelog \ud83d\udd17 0.1: Initial release of the package. \ud83d\udd17 Measure metrics in background using separate thread Support context manager to start and end measurement Support for cpu usage, memory usage and io using python \"resource\" package Store results in JSON files Automatically store measurement results in InfluxDB Visualization for displaying results in Grafana using InfluxDB","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#01-initial-release-of-the-package","text":"Measure metrics in background using separate thread Support context manager to start and end measurement Support for cpu usage, memory usage and io using python \"resource\" package Store results in JSON files Automatically store measurement results in InfluxDB Visualization for displaying results in Grafana using InfluxDB","title":"0.1: Initial release of the package."},{"location":"faq/","text":"FAQ \ud83d\udd17 What is the difference between python profilers like cProfile and multimeter? \ud83d\udd17 Profilers typically measure how the code behaves internally, e.g. which function was called most and took the longest time to run or where most of the memory was allocated. Profiling code in detail is costly and is therefore only done explicitly when one is trying to optimize some specific behavior. Multimeter in contrast doesn't care of the internals of code, but looks at the external effects of this code like cpu load, overall memory consumption or amount of io. This is comparatively cheap and can easily show potential bottlenecks. So, in short, multimeter allows identifying code that could have optimization potential and should be run using a profiler. Why do I get the warning \"Sampling lagging behind cycle time, ignore sleep\"? \ud83d\udd17 Usually the background thread waits until the measures are sampled next. If the sampling of all metrics takes longer than the cycle time, this warning is written to the log to indicate that the cycle time is too short for accurate measuring. The easiest fix for repeated warnings is increasing the cycle time.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#what-is-the-difference-between-python-profilers-like-cprofile-and-multimeter","text":"Profilers typically measure how the code behaves internally, e.g. which function was called most and took the longest time to run or where most of the memory was allocated. Profiling code in detail is costly and is therefore only done explicitly when one is trying to optimize some specific behavior. Multimeter in contrast doesn't care of the internals of code, but looks at the external effects of this code like cpu load, overall memory consumption or amount of io. This is comparatively cheap and can easily show potential bottlenecks. So, in short, multimeter allows identifying code that could have optimization potential and should be run using a profiler.","title":"What is the difference between python profilers like cProfile and multimeter?"},{"location":"faq/#why-do-i-get-the-warning-sampling-lagging-behind-cycle-time-ignore-sleep","text":"Usually the background thread waits until the measures are sampled next. If the sampling of all metrics takes longer than the cycle time, this warning is written to the log to indicate that the cycle time is too short for accurate measuring. The easiest fix for repeated warnings is increasing the cycle time.","title":"Why do I get the warning \"Sampling lagging behind cycle time, ignore sleep\"?"},{"location":"getting_started/","text":"Getting started \ud83d\udd17 Install the library \ud83d\udd17 Install the latest version from PyPI using pip: pip install multimeter Create a multimeter in your code \ud83d\udd17 Create a new instance of Multimeter with the probes it should use: import multimeter ... mm = multimeter . Multimeter ( multimeter . ResourceProbe ()) Measure while executing the code you want to measure \ud83d\udd17 with mm . measure ( identifier = 'measurement-id' ) as measurement : # Here the code whose performance should be measured ... Process the measured results \ud83d\udd17 print ( f \"Start { measurement . result . start } \" ) print ( f \"End { measurement . result . end } \" ) print ( f \"Duration { measurement . result . duration } \" ) print ( f \"CPU avg values: { measurement . result . values ( 'process.cpu_rate_user' ) } \" ) Automatically store the results as JSON \ud83d\udd17 mm . set_storage ( multimeter . JsonFileStorage ( save_directory = '/my/directory' )) Where to go from here? \ud83d\udd17 Read the user guide for some more in-depth explanation about multimeter. Multimeter supports different types of probes, that actually measure. A description of the individual classes with their respective metrics can be found in the documentation: Which metrics are available? multimeter.probe.ResourceProbe Where can I store the results? multimeter.storage.JsonFileStorage Creating your own probe: How to write your own probe? Creating your own storage: How to write your own probe?","title":"Getting started"},{"location":"getting_started/#getting-started","text":"","title":"Getting started"},{"location":"getting_started/#install-the-library","text":"Install the latest version from PyPI using pip: pip install multimeter","title":"Install the library"},{"location":"getting_started/#create-a-multimeter-in-your-code","text":"Create a new instance of Multimeter with the probes it should use: import multimeter ... mm = multimeter . Multimeter ( multimeter . ResourceProbe ())","title":"Create a multimeter in your code"},{"location":"getting_started/#measure-while-executing-the-code-you-want-to-measure","text":"with mm . measure ( identifier = 'measurement-id' ) as measurement : # Here the code whose performance should be measured ...","title":"Measure while executing the code you want to measure"},{"location":"getting_started/#process-the-measured-results","text":"print ( f \"Start { measurement . result . start } \" ) print ( f \"End { measurement . result . end } \" ) print ( f \"Duration { measurement . result . duration } \" ) print ( f \"CPU avg values: { measurement . result . values ( 'process.cpu_rate_user' ) } \" )","title":"Process the measured results"},{"location":"getting_started/#automatically-store-the-results-as-json","text":"mm . set_storage ( multimeter . JsonFileStorage ( save_directory = '/my/directory' ))","title":"Automatically store the results as JSON"},{"location":"getting_started/#where-to-go-from-here","text":"Read the user guide for some more in-depth explanation about multimeter. Multimeter supports different types of probes, that actually measure. A description of the individual classes with their respective metrics can be found in the documentation: Which metrics are available? multimeter.probe.ResourceProbe Where can I store the results? multimeter.storage.JsonFileStorage Creating your own probe: How to write your own probe? Creating your own storage: How to write your own probe?","title":"Where to go from here?"},{"location":"user_guide/","text":"User guide \ud83d\udd17 This user guide can be used as a starting point for getting a deeper understanding of the inner workings of the multimeter library. It is meant for users who want to learn about individual details or who plan to extend its features by developing own probes or storages. Install the library \ud83d\udd17 The library can be installed in two different ways: Use stable release from PyPI \ud83d\udd17 All stable versions of multimeter are available on PyPI and can be downloaded and installed from there. The easiest option to get it installed into your python environment is by using pip : pip install multimeter Use from source \ud83d\udd17 Multimeter's Git repository is available for everyone and can easily be cloned into a new repository on your local machine: $ cd /your/local/directory $ git clone https://gitlab.com/kantai/multimeter.git $ cd multimeter If you want to make changes to library, please follow the guidance in the README.md on how to setup the necessary tools for testing your changes. If you just want to use the library, it is sufficient to add the path to your local multimeter repository to your $PYTHONPATH variable, e.g.: $ export PYTHONPATH = \" $PYTHONPATH :/your/local/directory/multimeter\" How multimeter works \ud83d\udd17 First we start with some high-level description of the individual parts of the library. Multimeter \ud83d\udd17 Multimeter is the central class which is used by the user to start a measurement. A Multimeter takes the configuration, that defines what and how it is measured. This configuration is usually given directly as constructor arguments, when instantiating the object: import multimeter ... mm = multimeter . Multimeter ( multimeter . ResourceProbe (), cycle_time = 5.0 , storage = multimeter . DummyStorage (), ) Additionally, it can be (re-)configured later: import multimeter ... mm = multimeter . Multimeter () ... mm . add_probes ( multimeter . ResourceProbe ()) mm . set_cycle_time ( 5.0 ) mm . set_storage ( multimeter . DummyStorage ()) Probe \ud83d\udd17 For actually capturing the values, Multimeter uses an arbitrary number of Probe objects, which are either provided as positional arguments in the Multimeter constructor or are added after construction using add_probes . Each probe object can define describe values it captures. This is done using 3 different properties: metrics \ud83d\udd17 metrics contains a tuple of Metric objects, that describe different types of values that are captured, e.g. the CPU rate spend executing user code or the memory consumption. A metric can have additional attributes like the python type of the values, a minimum or maximum value or the unit as string that the value is in. These values are not checked or enforced in any way, but they can be useful for the interpretation of the results by the user or other tools. subjects \ud83d\udd17 subjects contains a tuple of Subject objects that describe where a metric can be captured, e.g. 'process' when capturing the memory usage of a process or a file system where the free disk space is captured. The supported subjects are Probe dependent, too. measures \ud83d\udd17 The measures attribute contains instances of type Measure , which references a single metric and a single subject. The key of a Measure matches the key under which the corresponding values are stored. start() and end() \ud83d\udd17 Probes can implement two methods start() and end() , which are called when a new measurement is started or finished. This allows the probe to set up and tear down some mechanism for collecting the values. Both methods are optional to use and the default implementations in the Probe base class don't do anything. Capturing values \ud83d\udd17 For actually capturing the values, Probe subclasses need to implement a method sample(values, time_span) . This method is given a dictionary values where the captured values should be added under the key of their corresponding Measure , and a value time_span which contains the number of seconds as float since the previous sample or since start() in case of the first call to sample() . The probes are expected to always set a value for each if its measures . Out of the box Multimeter contains the following Probe objects: ResourceProbe Measurement \ud83d\udd17 A new Measurement is created by calling the measure() method on a Multimeter object. measurement = mm . measure () measure() takes optional keyword arguments, that allows to identify individual measurements later on. If identifier is provided, its value is used as a (unique) identifier for this measurement: measurement = mm . measure ( identfieer = 'my-measurement' ) Additionally, arbitrary keyword arguments with string values can be given. Those are treated as tags that can help to either differentiate between multiple measurements or contain additional user-defined data: measurement = mm . measure ( identfieer = 'my-measurement' , my_tag = 'tag-value' , ) Measuring \ud83d\udd17 The measurement starts as soon as one calls start() . This starts a new thread which runs in the background and gathers the measurement values at regular intervals of length cycle_time . This is done until the measurement is ended by calling end() . measurement . start () here_my_code_to_be_measured () ... measurement . end () The Result . can be retrieved by explicitly getting it from the measurement, result = measurement . result but it's returned from start() , too. result = measurement . start () To make it more convenient the whole start() , end() sequence is simplified, when using the Measurement as a context manager: with multimeter . measure () as measurement : here_my_code_to_be_measured () Adding marks \ud83d\udd17 To make it easier to relate the code that is being measured with the measured values, a measurement allows adding marks programmatically using the method add_mark(label) . By calling this method the current time is saved together with the provided label. This allows to identify different code sections in a single measurement. with multimeter . measure () as measurement : here_my_code_to_be_measured () measurement . add_mark ( \"Next operation\" ) next_operation () measurement . add_mark ( \"final step\" ) final_step () Result \ud83d\udd17 A Result gives access to the measured values together with a description of the metrics and the subjects that were captured. points \ud83d\udd17 For each timestamp where values are gathered, point contain an individual object of type Point . Each point contains only two attributes: datetime : A python datetime.datetime value with timezone UTC that contains the timestamp when the values of the point were measured. values : A dict() which contains the values for all measures at this time. The types of the individual values depend on the value_type of the corresponding measure's metric. metrics \ud83d\udd17 metrics contains the union of all Metric objects defined by all probes that set the values in this result. subjects \ud83d\udd17 subjects contain the union of all Subject objects defined by all probes that set the values in this result. measures \ud83d\udd17 The measures attribute contains the union of all Measure , objects defined by all probes that set the values in this result. The key of a Measure matches the key under which the corresponding values are stored. meta_data \ud83d\udd17 All properties in the result are read-only. The only changes to the result by the user can be made by adding meta data using Result.add_meta_data(**meta_data) . The meta data values can be strings or other primitives. It is meant for storing additional information about the run, that can be useful for interpreting the result, e.g. instance type, operating system version, user account who executes the code etc. Storage \ud83d\udd17 Once a measurement is finished, its result can be automatically stored by a Storage . Storage classes need to implement only a single method: store(result) This method takes as only argument the Result of the measurement. Multimeter provides the following different Storage implementations: JsonFileStorage Extending multimeter \ud83d\udd17 Multimeter can easily be extended on two sides, gathering values and storing values. Implementing custom probe \ud83d\udd17 A new probe should inherit from the Probe base class. The only method that needs to be implemented is sample(values, time_span . In order to make it easier to understand, what different measures, subjects and metrics the new probe uses, the corresponding methods measures , subjects and metrics should be implemented and match, the values, that sample(values, time_span) defines. If applicable, some predefined metrics METRIC_* in multimeter.metrics and subjects SUBJECT_* in multimeter.subjects can be used. start() and end() can be implemented if useful for initialization or cleaning up. Implementing custom storage \ud83d\udd17 Implementing a custom storage class is quite easy. Inherit from the base class multimeter.storages.base.Storage and implement the method store(result) .","title":"User guide"},{"location":"user_guide/#user-guide","text":"This user guide can be used as a starting point for getting a deeper understanding of the inner workings of the multimeter library. It is meant for users who want to learn about individual details or who plan to extend its features by developing own probes or storages.","title":"User guide"},{"location":"user_guide/#install-the-library","text":"The library can be installed in two different ways:","title":"Install the library"},{"location":"user_guide/#use-stable-release-from-pypi","text":"All stable versions of multimeter are available on PyPI and can be downloaded and installed from there. The easiest option to get it installed into your python environment is by using pip : pip install multimeter","title":"Use stable release from PyPI"},{"location":"user_guide/#use-from-source","text":"Multimeter's Git repository is available for everyone and can easily be cloned into a new repository on your local machine: $ cd /your/local/directory $ git clone https://gitlab.com/kantai/multimeter.git $ cd multimeter If you want to make changes to library, please follow the guidance in the README.md on how to setup the necessary tools for testing your changes. If you just want to use the library, it is sufficient to add the path to your local multimeter repository to your $PYTHONPATH variable, e.g.: $ export PYTHONPATH = \" $PYTHONPATH :/your/local/directory/multimeter\"","title":"Use from source"},{"location":"user_guide/#how-multimeter-works","text":"First we start with some high-level description of the individual parts of the library.","title":"How multimeter works"},{"location":"user_guide/#multimeter","text":"Multimeter is the central class which is used by the user to start a measurement. A Multimeter takes the configuration, that defines what and how it is measured. This configuration is usually given directly as constructor arguments, when instantiating the object: import multimeter ... mm = multimeter . Multimeter ( multimeter . ResourceProbe (), cycle_time = 5.0 , storage = multimeter . DummyStorage (), ) Additionally, it can be (re-)configured later: import multimeter ... mm = multimeter . Multimeter () ... mm . add_probes ( multimeter . ResourceProbe ()) mm . set_cycle_time ( 5.0 ) mm . set_storage ( multimeter . DummyStorage ())","title":"Multimeter"},{"location":"user_guide/#probe","text":"For actually capturing the values, Multimeter uses an arbitrary number of Probe objects, which are either provided as positional arguments in the Multimeter constructor or are added after construction using add_probes . Each probe object can define describe values it captures. This is done using 3 different properties:","title":"Probe"},{"location":"user_guide/#metrics","text":"metrics contains a tuple of Metric objects, that describe different types of values that are captured, e.g. the CPU rate spend executing user code or the memory consumption. A metric can have additional attributes like the python type of the values, a minimum or maximum value or the unit as string that the value is in. These values are not checked or enforced in any way, but they can be useful for the interpretation of the results by the user or other tools.","title":"metrics"},{"location":"user_guide/#subjects","text":"subjects contains a tuple of Subject objects that describe where a metric can be captured, e.g. 'process' when capturing the memory usage of a process or a file system where the free disk space is captured. The supported subjects are Probe dependent, too.","title":"subjects"},{"location":"user_guide/#measures","text":"The measures attribute contains instances of type Measure , which references a single metric and a single subject. The key of a Measure matches the key under which the corresponding values are stored.","title":"measures"},{"location":"user_guide/#start-and-end","text":"Probes can implement two methods start() and end() , which are called when a new measurement is started or finished. This allows the probe to set up and tear down some mechanism for collecting the values. Both methods are optional to use and the default implementations in the Probe base class don't do anything.","title":"start() and end()"},{"location":"user_guide/#capturing-values","text":"For actually capturing the values, Probe subclasses need to implement a method sample(values, time_span) . This method is given a dictionary values where the captured values should be added under the key of their corresponding Measure , and a value time_span which contains the number of seconds as float since the previous sample or since start() in case of the first call to sample() . The probes are expected to always set a value for each if its measures . Out of the box Multimeter contains the following Probe objects: ResourceProbe","title":"Capturing values"},{"location":"user_guide/#measurement","text":"A new Measurement is created by calling the measure() method on a Multimeter object. measurement = mm . measure () measure() takes optional keyword arguments, that allows to identify individual measurements later on. If identifier is provided, its value is used as a (unique) identifier for this measurement: measurement = mm . measure ( identfieer = 'my-measurement' ) Additionally, arbitrary keyword arguments with string values can be given. Those are treated as tags that can help to either differentiate between multiple measurements or contain additional user-defined data: measurement = mm . measure ( identfieer = 'my-measurement' , my_tag = 'tag-value' , )","title":"Measurement"},{"location":"user_guide/#measuring","text":"The measurement starts as soon as one calls start() . This starts a new thread which runs in the background and gathers the measurement values at regular intervals of length cycle_time . This is done until the measurement is ended by calling end() . measurement . start () here_my_code_to_be_measured () ... measurement . end () The Result . can be retrieved by explicitly getting it from the measurement, result = measurement . result but it's returned from start() , too. result = measurement . start () To make it more convenient the whole start() , end() sequence is simplified, when using the Measurement as a context manager: with multimeter . measure () as measurement : here_my_code_to_be_measured ()","title":"Measuring"},{"location":"user_guide/#adding-marks","text":"To make it easier to relate the code that is being measured with the measured values, a measurement allows adding marks programmatically using the method add_mark(label) . By calling this method the current time is saved together with the provided label. This allows to identify different code sections in a single measurement. with multimeter . measure () as measurement : here_my_code_to_be_measured () measurement . add_mark ( \"Next operation\" ) next_operation () measurement . add_mark ( \"final step\" ) final_step ()","title":"Adding marks"},{"location":"user_guide/#result","text":"A Result gives access to the measured values together with a description of the metrics and the subjects that were captured.","title":"Result"},{"location":"user_guide/#points","text":"For each timestamp where values are gathered, point contain an individual object of type Point . Each point contains only two attributes: datetime : A python datetime.datetime value with timezone UTC that contains the timestamp when the values of the point were measured. values : A dict() which contains the values for all measures at this time. The types of the individual values depend on the value_type of the corresponding measure's metric.","title":"points"},{"location":"user_guide/#metrics_1","text":"metrics contains the union of all Metric objects defined by all probes that set the values in this result.","title":"metrics"},{"location":"user_guide/#subjects_1","text":"subjects contain the union of all Subject objects defined by all probes that set the values in this result.","title":"subjects"},{"location":"user_guide/#measures_1","text":"The measures attribute contains the union of all Measure , objects defined by all probes that set the values in this result. The key of a Measure matches the key under which the corresponding values are stored.","title":"measures"},{"location":"user_guide/#meta_data","text":"All properties in the result are read-only. The only changes to the result by the user can be made by adding meta data using Result.add_meta_data(**meta_data) . The meta data values can be strings or other primitives. It is meant for storing additional information about the run, that can be useful for interpreting the result, e.g. instance type, operating system version, user account who executes the code etc.","title":"meta_data"},{"location":"user_guide/#storage","text":"Once a measurement is finished, its result can be automatically stored by a Storage . Storage classes need to implement only a single method: store(result) This method takes as only argument the Result of the measurement. Multimeter provides the following different Storage implementations: JsonFileStorage","title":"Storage"},{"location":"user_guide/#extending-multimeter","text":"Multimeter can easily be extended on two sides, gathering values and storing values.","title":"Extending multimeter"},{"location":"user_guide/#implementing-custom-probe","text":"A new probe should inherit from the Probe base class. The only method that needs to be implemented is sample(values, time_span . In order to make it easier to understand, what different measures, subjects and metrics the new probe uses, the corresponding methods measures , subjects and metrics should be implemented and match, the values, that sample(values, time_span) defines. If applicable, some predefined metrics METRIC_* in multimeter.metrics and subjects SUBJECT_* in multimeter.subjects can be used. start() and end() can be implemented if useful for initialization or cleaning up.","title":"Implementing custom probe"},{"location":"user_guide/#implementing-custom-storage","text":"Implementing a custom storage class is quite easy. Inherit from the base class multimeter.storages.base.Storage and implement the method store(result) .","title":"Implementing custom storage"},{"location":"visualization/","text":"Visualization \ud83d\udd17 Multimeter brings with it a script for setting up a visualization, that allows to display the measured values. This visualization uses docker-compose to install and run its two components, InfluxDB for storing the measures values and Grafana that displays the values in dashboards. If the multimeter package is installed using pip , it comes with its own executable mm-visu : $ mm-visu --help usage: mm-visu [ -h ] [ -c CONFIG_FILE ] { install,remove,start,stop } ... positional arguments: { install,remove,start,stop } sub-command help install Create the necessary docker container and configure them remove Remove docker containers and remove the stored data start Start the visualization stop Stop the visualization optional arguments: -h, --help show this help message and exit -c CONFIG_FILE, --config CONFIG_FILE The file where the config for the visualization is stored. ( default: /home/<user>/.multimeter/visu.config.json ) If multimeter is used from source, the visualization script has to be run as a python module: $ python3 -m multimeter.visualization --help usage: visualization.py [ -h ] [ -c CONFIG_FILE ] { install,remove,start,stop } ... Install \ud83d\udd17 Before the visualization can be used its components need to be installed. This is done by running the 'install' command of the script: $ mm-visu install --help usage: mm-visu install [ -h ] [ -d DATA_DIR ] [ -o ORG ] [ -b BUCKET ] optional arguments: -h, --help show this help message and exit -d DATA_DIR, --dir DATA_DIR The directory where the data will be stored. -o ORG, --org ORG The organization in influx. -b BUCKET, --bucket BUCKET The bucket in influx for storing measurements. The install command takes some optional arguments: - DATA_DIR: The directory where the measurement data in InfluxDB will be stored. If no directory is given, the data will be stored within the users HOME directory. - ORG: All data in InfluxDB has to be assigned to an organization. The given organization automatically created during installation. It defaults to 'kantai'. - BUCKET: InfluxDB uses the concept of buckets for organizing data. The visualization uses a specific bucket, that be defined during install. If nothing is given, the bucket 'multimeter' is used. Once mm-visu install is being run, it downloads the required docker images, sets up the containers for running them, configures the applications according to the given values and loads some examples. At the end, it prints out some pointers on how to use the visualization: ... Visualization successfully set up. Example dashboard: http://localhost:3000/d/6V5fU2t7r/multimeter?orgId=1&var-measurementId=example&from=1638479887312&to=1638479894580 Default username/password: admin/admin Database UI: http://localhost:8086/ Default username/password: admin/admin123 Stop & Start \ud83d\udd17 Once installed, the visualization is automatically run. It can be explicitly stopped and started again without reinstalling by calling mm-visu stop or mm-visu start . Remove \ud83d\udd17 Once the visualization is no longer needed, it can completely removed. This is done by calling mm-visu remove . This removes the created docker container and additionally deletes the data directory, where the measured values are stored. Using the visualization \ud83d\udd17 Once installed, the visualization can be accessed using the URL of example dashboard. The dashboard shows the values that were gathered using the ResourceProbe . New measurements can be automatically stored in the database using the InfluxDBStorage : meter = Multimeter ( ResourceProbe (), storage = InfluxDBStorage ( token = '<my-token>' , )) with meter . measure ( identifier = '<my-identifier>' ) as measurement : # code to measure The measurement identifier is used for loading measurement results in the visualization: Limiting the time range to the range in which the measurement had happened, can be done by clicking the \"Full time range\" link: Troubleshooting \ud83d\udd17 When I run the script, I get an error about missing 'docker-compose'? \ud83d\udd17 The uses docker-compose to install and run the individual container that work together as the visualization. Please follow https://docs.docker.com/compose/install/ to install 'docker-compose' and make sure that the 'docker-compose' binary is available in the $PATH environment variable.","title":"Visualization"},{"location":"visualization/#visualization","text":"Multimeter brings with it a script for setting up a visualization, that allows to display the measured values. This visualization uses docker-compose to install and run its two components, InfluxDB for storing the measures values and Grafana that displays the values in dashboards. If the multimeter package is installed using pip , it comes with its own executable mm-visu : $ mm-visu --help usage: mm-visu [ -h ] [ -c CONFIG_FILE ] { install,remove,start,stop } ... positional arguments: { install,remove,start,stop } sub-command help install Create the necessary docker container and configure them remove Remove docker containers and remove the stored data start Start the visualization stop Stop the visualization optional arguments: -h, --help show this help message and exit -c CONFIG_FILE, --config CONFIG_FILE The file where the config for the visualization is stored. ( default: /home/<user>/.multimeter/visu.config.json ) If multimeter is used from source, the visualization script has to be run as a python module: $ python3 -m multimeter.visualization --help usage: visualization.py [ -h ] [ -c CONFIG_FILE ] { install,remove,start,stop } ...","title":"Visualization"},{"location":"visualization/#install","text":"Before the visualization can be used its components need to be installed. This is done by running the 'install' command of the script: $ mm-visu install --help usage: mm-visu install [ -h ] [ -d DATA_DIR ] [ -o ORG ] [ -b BUCKET ] optional arguments: -h, --help show this help message and exit -d DATA_DIR, --dir DATA_DIR The directory where the data will be stored. -o ORG, --org ORG The organization in influx. -b BUCKET, --bucket BUCKET The bucket in influx for storing measurements. The install command takes some optional arguments: - DATA_DIR: The directory where the measurement data in InfluxDB will be stored. If no directory is given, the data will be stored within the users HOME directory. - ORG: All data in InfluxDB has to be assigned to an organization. The given organization automatically created during installation. It defaults to 'kantai'. - BUCKET: InfluxDB uses the concept of buckets for organizing data. The visualization uses a specific bucket, that be defined during install. If nothing is given, the bucket 'multimeter' is used. Once mm-visu install is being run, it downloads the required docker images, sets up the containers for running them, configures the applications according to the given values and loads some examples. At the end, it prints out some pointers on how to use the visualization: ... Visualization successfully set up. Example dashboard: http://localhost:3000/d/6V5fU2t7r/multimeter?orgId=1&var-measurementId=example&from=1638479887312&to=1638479894580 Default username/password: admin/admin Database UI: http://localhost:8086/ Default username/password: admin/admin123","title":"Install"},{"location":"visualization/#stop-start","text":"Once installed, the visualization is automatically run. It can be explicitly stopped and started again without reinstalling by calling mm-visu stop or mm-visu start .","title":"Stop &amp; Start"},{"location":"visualization/#remove","text":"Once the visualization is no longer needed, it can completely removed. This is done by calling mm-visu remove . This removes the created docker container and additionally deletes the data directory, where the measured values are stored.","title":"Remove"},{"location":"visualization/#using-the-visualization","text":"Once installed, the visualization can be accessed using the URL of example dashboard. The dashboard shows the values that were gathered using the ResourceProbe . New measurements can be automatically stored in the database using the InfluxDBStorage : meter = Multimeter ( ResourceProbe (), storage = InfluxDBStorage ( token = '<my-token>' , )) with meter . measure ( identifier = '<my-identifier>' ) as measurement : # code to measure The measurement identifier is used for loading measurement results in the visualization: Limiting the time range to the range in which the measurement had happened, can be done by clicking the \"Full time range\" link:","title":"Using the visualization"},{"location":"visualization/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"visualization/#when-i-run-the-script-i-get-an-error-about-missing-docker-compose","text":"The uses docker-compose to install and run the individual container that work together as the visualization. Please follow https://docs.docker.com/compose/install/ to install 'docker-compose' and make sure that the 'docker-compose' binary is available in the $PATH environment variable.","title":"When I run the script, I get an error about missing 'docker-compose'?"},{"location":"probes/resource/","text":"ResourceProbe \ud83d\udd17 The multimeter.probe.ResourceProbe uses the python standard module resource that provides access to cpu load, memory usage and io metrics. Unfortunately, the module is only available on unix. Metrics \ud83d\udd17 METRIC_CPU_RATE_USER: Rate of time spent in user side code per second METRIC_CPU_RATE_SYSTEM: Rate of time spent in user side code per second METRIC_MEMORY_MAX: Total memory allocated in kB. METRIC_MEMORY_SHARED: Shared memory with other processes in kB. METRIC_MEMORY_DATA: Memory used for data in kB. METRIC_MEMORY_STACK: Memory used for stacks in kB. METRIC_MEMORY_PAGE_FAULTS_WITH_IO: Number of page faults per second that lead to io. METRIC_MEMORY_PAGE_FAULTS_WITHOUT_IO: Number of page faults per second that didn't lead to io. METRIC_MEMORY_SWAP_OPS: Number of swap operations per second. METRIC_IO_BLOCK_IN: Number of data blocks read per second. METRIC_IO_BLOCK_OUT: Number of data blocks writes per second. METRIC_CONTEXT_SWITCHES_VOL: Number of voluntary context switches per seconds. METRIC_CONTEXT_SWITCHES_INVOL: Number of involuntary context switches per seconds. See https://man7.org/linux/man-pages/man2/getrusage.2.html for more details. Subjects \ud83d\udd17 SUBJECT_PROCESS: The python process. SUBJECT_CHILDREN: The child processes of the python process.","title":"Resource"},{"location":"probes/resource/#resourceprobe","text":"The multimeter.probe.ResourceProbe uses the python standard module resource that provides access to cpu load, memory usage and io metrics. Unfortunately, the module is only available on unix.","title":"ResourceProbe"},{"location":"probes/resource/#metrics","text":"METRIC_CPU_RATE_USER: Rate of time spent in user side code per second METRIC_CPU_RATE_SYSTEM: Rate of time spent in user side code per second METRIC_MEMORY_MAX: Total memory allocated in kB. METRIC_MEMORY_SHARED: Shared memory with other processes in kB. METRIC_MEMORY_DATA: Memory used for data in kB. METRIC_MEMORY_STACK: Memory used for stacks in kB. METRIC_MEMORY_PAGE_FAULTS_WITH_IO: Number of page faults per second that lead to io. METRIC_MEMORY_PAGE_FAULTS_WITHOUT_IO: Number of page faults per second that didn't lead to io. METRIC_MEMORY_SWAP_OPS: Number of swap operations per second. METRIC_IO_BLOCK_IN: Number of data blocks read per second. METRIC_IO_BLOCK_OUT: Number of data blocks writes per second. METRIC_CONTEXT_SWITCHES_VOL: Number of voluntary context switches per seconds. METRIC_CONTEXT_SWITCHES_INVOL: Number of involuntary context switches per seconds. See https://man7.org/linux/man-pages/man2/getrusage.2.html for more details.","title":"Metrics"},{"location":"probes/resource/#subjects","text":"SUBJECT_PROCESS: The python process. SUBJECT_CHILDREN: The child processes of the python process.","title":"Subjects"},{"location":"storages/influx/","text":"InfluxDBStorage \ud83d\udd17 The multimeter.storages.influx.InfluxDBStorage exports all Result to an Influx time series database. InfluxDBStorage uses the official influxdb_client library and therefore, depends on its package to be installed. It can be automatically installed alongside multimeter by installing its optional extra [influxdb] : pip install multimeter [ influxdb ] Configuration \ud83d\udd17 All configuration values are given as arguments to the InfluxDBStorage constructor __init__() token is required and given as a positional argument, where all other values of the configuration are optional keyword values. token \ud83d\udd17 The InfluxDBStorage requires an authentication token to be able to write data to the database. This token can be manually created in the InfluxDB user interface or in an automated fashion using InfluxDB clients. url \ud83d\udd17 The url value defines the URL of the InfluxDB server instance to which the data will be sent. The url can be left out in which case, the URL of a server running on localhost with the default port is being use: 'http://localhost:8086' org \ud83d\udd17 Every data in an InfluxDB is assigned to be owned by an organization. The organizations are defined by the InfluxDB server and can be managed using its UI. As a default multimeter uses an organization 'kantai', but if this organization is not defined, InfluxDB will send an error 'organization name \\\"kantai\\\" not found'. bucket \ud83d\udd17 In InfluxDB data can be stored in different buckets. The name of the bucket can be specified as part of the configuration. If no value is given for bucket , multimeter expects a bucket with name multimeter . Example \ud83d\udd17 from multimeter import Multimeter , ResourceProbe from multimeter.storages.influx import InfluxDBStorage meter = Multimeter ( ResourceProbe (), storage = InfluxDBStorage ( 'IWWNNY1xWuyxKCoc_KiucH-u9E6hqeXFXzi49sKzQY5VhZgdwqbrMJCF_z7xQocd_20xuuH1kMNgRnPzrvmIOA==' , url = 'http://influxdb2.my.tld:8086' , org = 'my-org' , bucket = 'my-bucket' , ))","title":"InfluxDB"},{"location":"storages/influx/#influxdbstorage","text":"The multimeter.storages.influx.InfluxDBStorage exports all Result to an Influx time series database. InfluxDBStorage uses the official influxdb_client library and therefore, depends on its package to be installed. It can be automatically installed alongside multimeter by installing its optional extra [influxdb] : pip install multimeter [ influxdb ]","title":"InfluxDBStorage"},{"location":"storages/influx/#configuration","text":"All configuration values are given as arguments to the InfluxDBStorage constructor __init__() token is required and given as a positional argument, where all other values of the configuration are optional keyword values.","title":"Configuration"},{"location":"storages/influx/#token","text":"The InfluxDBStorage requires an authentication token to be able to write data to the database. This token can be manually created in the InfluxDB user interface or in an automated fashion using InfluxDB clients.","title":"token"},{"location":"storages/influx/#url","text":"The url value defines the URL of the InfluxDB server instance to which the data will be sent. The url can be left out in which case, the URL of a server running on localhost with the default port is being use: 'http://localhost:8086'","title":"url"},{"location":"storages/influx/#org","text":"Every data in an InfluxDB is assigned to be owned by an organization. The organizations are defined by the InfluxDB server and can be managed using its UI. As a default multimeter uses an organization 'kantai', but if this organization is not defined, InfluxDB will send an error 'organization name \\\"kantai\\\" not found'.","title":"org"},{"location":"storages/influx/#bucket","text":"In InfluxDB data can be stored in different buckets. The name of the bucket can be specified as part of the configuration. If no value is given for bucket , multimeter expects a bucket with name multimeter .","title":"bucket"},{"location":"storages/influx/#example","text":"from multimeter import Multimeter , ResourceProbe from multimeter.storages.influx import InfluxDBStorage meter = Multimeter ( ResourceProbe (), storage = InfluxDBStorage ( 'IWWNNY1xWuyxKCoc_KiucH-u9E6hqeXFXzi49sKzQY5VhZgdwqbrMJCF_z7xQocd_20xuuH1kMNgRnPzrvmIOA==' , url = 'http://influxdb2.my.tld:8086' , org = 'my-org' , bucket = 'my-bucket' , ))","title":"Example"},{"location":"storages/jsonfile/","text":"JsonFileStorage \ud83d\udd17 The multimeter.storages.json.JsonFileStorage exports all Result to the file system using JSON. Configuration \ud83d\udd17 The only configuration that multimeter.storages.json.JsonFileStorage.__init__ takes is a path to a directory, where the JSON files will be stored. Format \ud83d\udd17 The json structure is a single object with fixed attributes: { \"identifier\" : \"measure-id\" , \"tags\" : { \"tag\" : \"value\" }, \"meta_data\" : {}, \"schema\" : { \"metrics\" : [ { \"key\" : \"cpu_rate_user\" , \"description\" : \"The rate of the time where the CPU is executing user-space code.\" , \"unit\" : \"\" , \"value_type\" : \"float\" , \"min_value\" : 0.0 , \"max_value\" : 1.0 }, { \"key\" : \"cpu_rate_system\" , \"description\" : \"The rate of the time where the CPU is executing system code.\" , \"unit\" : \"\" , \"value_type\" : \"float\" , \"min_value\" : 0.0 , \"max_value\" : 1.0 } ], \"subjects\" : [ { \"key\" : \"process\" , \"description\" : \"The current running process.\" } ], \"measures\" : [ { \"key\" : \"process.cpu_rate_user\" , \"subject\" : \"process\" , \"metric\" : \"cpu_rate_user\" }, { \"key\" : \"process.cpu_rate_system\" , \"subject\" : \"process\" , \"metric\" : \"cpu_rate_system\" } ] }, \"points\" : [ { \"datetime\" : \"2021-11-27T18:43:51.033+00:00\" , \"values\" : { \"process.cpu_rate_user\" : 0.8287030088703983 , \"process.cpu_rate_system\" : 0.2367722882486841 } }, { \"datetime\" : \"2021-11-27T18:43:52.039+00:00\" , \"values\" : { \"process.cpu_rate_user\" : 1.0000167626132233 , \"process.cpu_rate_system\" : 5.469854836835e-05 } } ], \"marks\" : [ { \"datetime\" : \"2021-11-27T18:43:51.733+00:00\" , \"label\" : \"Call X\" } ] } identifier \ud83d\udd17 The identifier for the measurement, which created this result. tags \ud83d\udd17 Tags are user-defined when the measurement is created. meta_data \ud83d\udd17 Contains the meta data that can be added to the result using add_meta_data() . schema \ud83d\udd17 The schema contains a description of the different values that are measured. Their definition originates the metrics, subjects and measures: metrics \ud83d\udd17 A list of objects describing the metrics that are included in the results. Each object contains the attributes \"key\", \"description\", \"unit\", \"value_type\", \"min_value\" and \"max_value\". subjects \ud83d\udd17 A list of objects where each object represents a subject from which the metrics were sampled. Each object contains a \"key\" and a human-readable \"description\". measure \ud83d\udd17 A list of objects representing individual measures describing which metric was sampled for which subject. Each object contains a \"key\" and references to a \"subject\" and a \"metric\". points \ud83d\udd17 The list of individual measuring points. Each point has an attribute \"datetime\" containing the datetime (UTC) the values were measured and an attribute \"values\" with a javascript object, where the keys reference the measures and the values contain the measured values at this time. marks \ud83d\udd17 The list of timestamps with a mark. Each mark has an attribute \"datetime\" containing the datetime (UTC) and an attribute \"label\" which contains the label of the mark, that was given when the mark was made.","title":"JsonFile"},{"location":"storages/jsonfile/#jsonfilestorage","text":"The multimeter.storages.json.JsonFileStorage exports all Result to the file system using JSON.","title":"JsonFileStorage"},{"location":"storages/jsonfile/#configuration","text":"The only configuration that multimeter.storages.json.JsonFileStorage.__init__ takes is a path to a directory, where the JSON files will be stored.","title":"Configuration"},{"location":"storages/jsonfile/#format","text":"The json structure is a single object with fixed attributes: { \"identifier\" : \"measure-id\" , \"tags\" : { \"tag\" : \"value\" }, \"meta_data\" : {}, \"schema\" : { \"metrics\" : [ { \"key\" : \"cpu_rate_user\" , \"description\" : \"The rate of the time where the CPU is executing user-space code.\" , \"unit\" : \"\" , \"value_type\" : \"float\" , \"min_value\" : 0.0 , \"max_value\" : 1.0 }, { \"key\" : \"cpu_rate_system\" , \"description\" : \"The rate of the time where the CPU is executing system code.\" , \"unit\" : \"\" , \"value_type\" : \"float\" , \"min_value\" : 0.0 , \"max_value\" : 1.0 } ], \"subjects\" : [ { \"key\" : \"process\" , \"description\" : \"The current running process.\" } ], \"measures\" : [ { \"key\" : \"process.cpu_rate_user\" , \"subject\" : \"process\" , \"metric\" : \"cpu_rate_user\" }, { \"key\" : \"process.cpu_rate_system\" , \"subject\" : \"process\" , \"metric\" : \"cpu_rate_system\" } ] }, \"points\" : [ { \"datetime\" : \"2021-11-27T18:43:51.033+00:00\" , \"values\" : { \"process.cpu_rate_user\" : 0.8287030088703983 , \"process.cpu_rate_system\" : 0.2367722882486841 } }, { \"datetime\" : \"2021-11-27T18:43:52.039+00:00\" , \"values\" : { \"process.cpu_rate_user\" : 1.0000167626132233 , \"process.cpu_rate_system\" : 5.469854836835e-05 } } ], \"marks\" : [ { \"datetime\" : \"2021-11-27T18:43:51.733+00:00\" , \"label\" : \"Call X\" } ] }","title":"Format"},{"location":"storages/jsonfile/#identifier","text":"The identifier for the measurement, which created this result.","title":"identifier"},{"location":"storages/jsonfile/#tags","text":"Tags are user-defined when the measurement is created.","title":"tags"},{"location":"storages/jsonfile/#meta_data","text":"Contains the meta data that can be added to the result using add_meta_data() .","title":"meta_data"},{"location":"storages/jsonfile/#schema","text":"The schema contains a description of the different values that are measured. Their definition originates the metrics, subjects and measures:","title":"schema"},{"location":"storages/jsonfile/#metrics","text":"A list of objects describing the metrics that are included in the results. Each object contains the attributes \"key\", \"description\", \"unit\", \"value_type\", \"min_value\" and \"max_value\".","title":"metrics"},{"location":"storages/jsonfile/#subjects","text":"A list of objects where each object represents a subject from which the metrics were sampled. Each object contains a \"key\" and a human-readable \"description\".","title":"subjects"},{"location":"storages/jsonfile/#measure","text":"A list of objects representing individual measures describing which metric was sampled for which subject. Each object contains a \"key\" and references to a \"subject\" and a \"metric\".","title":"measure"},{"location":"storages/jsonfile/#points","text":"The list of individual measuring points. Each point has an attribute \"datetime\" containing the datetime (UTC) the values were measured and an attribute \"values\" with a javascript object, where the keys reference the measures and the values contain the measured values at this time.","title":"points"},{"location":"storages/jsonfile/#marks","text":"The list of timestamps with a mark. Each mark has an attribute \"datetime\" containing the datetime (UTC) and an attribute \"label\" which contains the label of the mark, that was given when the mark was made.","title":"marks"}]}